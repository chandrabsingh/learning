
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>Coding Challenges</title>
    
  <!-- Loaded before other Sphinx assets -->
  <link href="../_static/styles/theme.css?digest=1999514e3f237ded88cf" rel="stylesheet">
<link href="../_static/styles/pydata-sphinx-theme.css?digest=1999514e3f237ded88cf" rel="stylesheet">

    
  <link rel="stylesheet"
    href="../_static/vendor/fontawesome/5.13.0/css/all.min.css">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../_static/vendor/fontawesome/5.13.0/webfonts/fa-solid-900.woff2">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../_static/vendor/fontawesome/5.13.0/webfonts/fa-brands-400.woff2">

    <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" href="../_static/styles/sphinx-book-theme.css?digest=5115cc725059bd94278eecd172e13a965bf8f5a9" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../_static/togglebutton.css" />
    <link rel="stylesheet" type="text/css" href="../_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="../_static/mystnb.css" />
    <link rel="stylesheet" type="text/css" href="../_static/sphinx-thebe.css" />
    <link rel="stylesheet" type="text/css" href="../_static/design-style.b7bb847fb20b106c3d81b95245e65545.min.css" />
    
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../_static/scripts/pydata-sphinx-theme.js?digest=1999514e3f237ded88cf">

    <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/clipboard.min.js"></script>
    <script src="../_static/copybutton.js"></script>
    <script src="../_static/scripts/sphinx-book-theme.js?digest=9c920249402e914e316237a7dbc6769907cce411"></script>
    <script>let toggleHintShow = 'Click to show';</script>
    <script>let toggleHintHide = 'Click to hide';</script>
    <script>let toggleOpenOnPrint = 'true';</script>
    <script src="../_static/togglebutton.js"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown, .tag_hide_input div.cell_input, .tag_hide-input div.cell_input, .tag_hide_output div.cell_output, .tag_hide-output div.cell_output, .tag_hide_cell.cell, .tag_hide-cell.cell';</script>
    <script src="../_static/design-tabs.js"></script>
    <script>const THEBE_JS_URL = "https://unpkg.com/thebe@0.8.2/lib/index.js"
const thebe_selector = ".thebe,.cell"
const thebe_selector_input = "pre"
const thebe_selector_output = ".output, .cell_output"
</script>
    <script async="async" src="../_static/sphinx-thebe.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Python Data Analytics - FAQs" href="../codes/python_data_analytics.html" />
    <link rel="prev" title="Python FAQs" href="../codes/python_faqs.html" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="docsearch:language" content="None">
    

    <!-- Google Analytics -->
    
  </head>
  <body data-spy="scroll" data-target="#bd-toc-nav" data-offset="60">
<!-- Checkboxes to toggle the left sidebar -->
<input type="checkbox" class="sidebar-toggle" name="__navigation" id="__navigation" aria-label="Toggle navigation sidebar">
<label class="overlay overlay-navbar" for="__navigation">
    <div class="visually-hidden">Toggle navigation sidebar</div>
</label>
<!-- Checkboxes to toggle the in-page toc -->
<input type="checkbox" class="sidebar-toggle" name="__page-toc" id="__page-toc" aria-label="Toggle in-page Table of Contents">
<label class="overlay overlay-pagetoc" for="__page-toc">
    <div class="visually-hidden">Toggle in-page Table of Contents</div>
</label>
<!-- Headers at the top -->
<div class="announcement header-item noprint"></div>
<div class="header header-item noprint"></div>

    
    <div class="container-fluid" id="banner"></div>

    

    <div class="container-xl">
      <div class="row">
          
<!-- Sidebar -->
<div class="bd-sidebar noprint" id="site-navigation">
    <div class="bd-sidebar__content">
        <div class="bd-sidebar__top"><div class="navbar-brand-box">
    <a class="navbar-brand text-wrap" href="../index.html">
      
        <!-- `logo` is deprecated in Sphinx 4.0, so remove this when we stop supporting 3 -->
        
      
      
      <img src="../_static/mylogo.png" class="logo" alt="logo">
      
      
    </a>
</div><form class="bd-search d-flex align-items-center" action="../search.html" method="get">
  <i class="icon fas fa-search"></i>
  <input type="search" class="form-control" name="q" id="search-input" placeholder="Search this book..." aria-label="Search this book..." autocomplete="off" >
</form><nav class="bd-links" id="bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item active">
        
        <ul class="nav bd-sidenav bd-sidenav__home-link">
            <li class="toctree-l1">
                <a class="reference internal" href="../intro.html">
                    Welcome
                </a>
            </li>
        </ul>
        <p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  System Design
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="../system_design/intro.html">
   My System Design Book
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-1" name="toctree-checkbox-1" type="checkbox"/>
  <label for="toctree-checkbox-1">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="../system_design/design_patterns.html">
     System Design Summary
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../system_design/software_engineering_concepts.html">
     Software Engineering concepts
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../system_design/googlecloud_use_cases.html">
     Google - Customer story
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../system_design/awscloud_financial_symposium_2022.html">
     AWS - Financial Services Cloud Symposium - 2022
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../system_design/aws_usecases.html">
     AWS - Customer story
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../system_design/design_general_use_cases.html">
     Case study
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../system_design/netflix.html">
     Netflix creativity
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../system_design/bk_AlexXu_SystemDesignInterview.html">
     Book - System Design Interview - Alex Xu
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../system_design/design_patterns_python.html">
     Design Pattern - Python
    </a>
   </li>
  </ul>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  Code
 </span>
</p>
<ul class="current nav bd-sidenav">
 <li class="toctree-l1 current active has-children">
  <a class="reference internal" href="../codes/intro.html">
   My Code Book
  </a>
  <input checked="" class="toctree-checkbox" id="toctree-checkbox-2" name="toctree-checkbox-2" type="checkbox"/>
  <label for="toctree-checkbox-2">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul class="current">
   <li class="toctree-l2">
    <a class="reference internal" href="../codes/python_faqs.html">
     Python FAQs
    </a>
   </li>
   <li class="toctree-l2 current active">
    <a class="current reference internal" href="#">
     Coding Challenges
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../codes/python_data_analytics.html">
     Python Data Analytics - FAQs
    </a>
   </li>
  </ul>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  Database/Event
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="../dbs/intro.html">
   My DB Book
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-3" name="toctree-checkbox-3" type="checkbox"/>
  <label for="toctree-checkbox-3">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="../dbs/intro_kafka_ksqldb_stream_processing.html">
     Introduction to Kafka/ksqldb/stream processing
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../dbs/neo4j_basics.html">
     Building Neo4j Applications with Python
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../dbs/neo4j_graph_datascience.html">
     Game of Thrones - Knowledge Graph analysis using Neo4j
    </a>
   </li>
  </ul>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  Math
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="../maths/intro.html">
   My Math Book
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-4" name="toctree-checkbox-4" type="checkbox"/>
  <label for="toctree-checkbox-4">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="../maths/probability_simulations.html">
     Probability Games using Simulations
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../maths/linear_algebra.html">
     Linear Algebra - FAQs
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../maths/probabilistic_programming.html">
     Getting started with PyMC3
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../maths/causal_inference_learning.html">
     Causal Inference Learning
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../econometrics/SARIMA_modeling.html">
     SARIMA modeling
    </a>
   </li>
  </ul>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  Machine Learning
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="../ml_examples/intro.html">
   My ML Book
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-5" name="toctree-checkbox-5" type="checkbox"/>
  <label for="toctree-checkbox-5">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="../ml_examples/ml_glossary.html">
     ML Conceptual brief
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../ml_examples/Store_Sales_Forecasting_With_Tensorflow.html">
     Store Sales Forecasting with TensorFlow
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../ml_examples/decision_tree_classification.html">
     Decision Tree - classification
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../ml_examples/ml_design_patterns.html">
     Machine Learning Design Patterns
    </a>
   </li>
  </ul>
 </li>
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="../dl_examples/intro.html">
   My DL Book
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-6" name="toctree-checkbox-6" type="checkbox"/>
  <label for="toctree-checkbox-6">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="../dl_examples/dl_glossary.html">
     DL Conceptual brief
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../dl_examples/rp_AlexNet.html">
     AlexNet Summary
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../dl_examples/rp_ResNet.html">
     ResNet Summary
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../dl_examples/Anima_Anandkumar_Retrospective_Role_of_Tensors_in_Machine_Learning.html">
     Anima Anandkumar - Retrospective Role of Tensors in ML
    </a>
   </li>
  </ul>
 </li>
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="../recommenders/intro.html">
   My Recommenders Book
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-7" name="toctree-checkbox-7" type="checkbox"/>
  <label for="toctree-checkbox-7">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="../recommenders/als_deep_dive.html">
     Spark Collaborative Filtering (ALS) Deep Dive
    </a>
   </li>
  </ul>
 </li>
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="../rl_examples/intro.html">
   My RL Book
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-8" name="toctree-checkbox-8" type="checkbox"/>
  <label for="toctree-checkbox-8">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="../rl_examples/mab_ts_ab.html">
     Multi-armed bandit problem
    </a>
   </li>
  </ul>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  Shell Scripting
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="../unix/intro.html">
   My Unix/Shell Book
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-9" name="toctree-checkbox-9" type="checkbox"/>
  <label for="toctree-checkbox-9">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="../unix/unix_shell_script.html">
     Unix/Shell FAQs
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../unix/my_zshrc.html">
     My .zshrc script
    </a>
   </li>
  </ul>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  Lecture Notes
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="../cs229_ml/intro.html">
   CS229 ML - by Andrew Ng
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-10" name="toctree-checkbox-10" type="checkbox"/>
  <label for="toctree-checkbox-10">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="../cs229_ml/lec02-LinearReg-GradientDescent.html">
     Lec 02-Linear Regression - Gradient Descent
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../cs229_ml/lec03-LocallyWeighted-LogisticRegression.html">
     Lec 03-Locally Weighted Regression - Logistic Regression
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../cs229_ml/lec04-Perceptron-GLM.html">
     Lec 04-Perceptron - GLM
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../cs229_ml/lec05-GDA-NaiveBayes.html">
     Lec 05-GDA - Naive Bayes
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../cs229_ml/lec06-NaiveBayes-SVM.html">
     Lec 06-Naive Bayes - SVM
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../cs229_ml/lec07-Kernels-SVM.html">
     Lec 07-Kernels - SVM
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../cs229_ml/lec08-DataSplits-Models-CrossValidation.html">
     Lec 08-Data Splits - Models - Cross Validation
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../cs229_ml/lec09-Approx-EstimationError-ERM.html">
     Lec 09-Estimation Error - ERM
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../cs229_ml/lec10-DecisionTrees-EnsembleMethods.html">
     Lec 10-Decision Trees - Ensemble Methods
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../cs229_ml/lec11-Intro-NN.html">
     Lec 11-Neural Networks
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../cs229_ml/lec12-Backpropagation-ImprovingNN.html">
     Lec 12-Improving NN
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../cs229_ml/lec13-DebuggingMLModels-ErrorAnalysis.html">
     Lec 13-Debugging ML Models-Error Analysis
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../cs229_ml/lec14-Expectation-MaximizationAlgo.html">
     Lec 14-Expectation-Maximization Algo
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../cs229_ml/lec15-EMAlgo-FactorAnalysis.html">
     Lec 15-EM Algo-Factor Analysis
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../cs229_ml/lec16-IndependentComponentAnalysis-RL.html">
     Lec 16-Independent Component Analysis-RL
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../cs229_ml/lec17-MDPs-ValuePolicyIteration.html">
     Lec 17-MDPs-Value Policy Iteration
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../cs229_ml/lec18-continuousMDPs-ModelSimulation.html">
     Lec 18-Continuous MDPs-Model Simulation
    </a>
   </li>
  </ul>
 </li>
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="../cs224w_ml_graph/intro.html">
   CS224W: Machine Learning with Graphs - by Jure Leskovev
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-11" name="toctree-checkbox-11" type="checkbox"/>
  <label for="toctree-checkbox-11">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="../cs224w_ml_graph/lec01_Introduction_MLforGraphs.html">
     Introduction ML for Graphs
    </a>
   </li>
  </ul>
 </li>
</ul>

    </div>
</nav></div>
        <div class="bd-sidebar__bottom">
             <!-- To handle the deprecated key -->
            
            <div class="navbar_extra_footer">
            Powered by <a href="https://jupyterbook.org">Jupyter Book</a>
            </div>
            
        </div>
    </div>
    <div id="rtd-footer-container"></div>
</div>


          


          
<!-- A tiny helper pixel to detect if we've scrolled -->
<div class="sbt-scroll-pixel-helper"></div>
<!-- Main content -->
<div class="col py-0 content-container">
    
    <div class="header-article row sticky-top noprint">
        



<div class="col py-1 d-flex header-article-main">
    <div class="header-article__left">
        
        <label for="__navigation"
  class="headerbtn"
  data-toggle="tooltip"
data-placement="right"
title="Toggle navigation"
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-bars"></i>
  </span>

</label>

        
    </div>
    <div class="header-article__right">
<div class="menu-dropdown menu-dropdown-launch-buttons">
  <button class="headerbtn menu-dropdown__trigger"
      aria-label="Launch interactive content">
      <i class="fas fa-rocket"></i>
  </button>
  <div class="menu-dropdown__content">
    <ul>
      <li>
        <a href="https://mybinder.org/v2/gh/chandrabsingh/learning/master?urlpath=tree/learning/algos/all_algos.ipynb"
   class="headerbtn"
   data-toggle="tooltip"
data-placement="left"
title="Launch on Binder"
>
  

<span class="headerbtn__icon-container">
  
    <img src="../_static/images/logo_binder.svg">
  </span>
<span class="headerbtn__text-container">Binder</span>
</a>

      </li>
      
    </ul>
  </div>
</div>

<button onclick="toggleFullScreen()"
  class="headerbtn"
  data-toggle="tooltip"
data-placement="bottom"
title="Fullscreen mode"
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-expand"></i>
  </span>

</button>

<div class="menu-dropdown menu-dropdown-repository-buttons">
  <button class="headerbtn menu-dropdown__trigger"
      aria-label="Source repositories">
      <i class="fab fa-github"></i>
  </button>
  <div class="menu-dropdown__content">
    <ul>
      <li>
        <a href="https://github.com/chandrabsingh/learning"
   class="headerbtn"
   data-toggle="tooltip"
data-placement="left"
title="Source repository"
>
  

<span class="headerbtn__icon-container">
  <i class="fab fa-github"></i>
  </span>
<span class="headerbtn__text-container">repository</span>
</a>

      </li>
      
      <li>
        <a href="https://github.com/chandrabsingh/learning/issues/new?title=Issue%20on%20page%20%2Falgos/all_algos.html&body=Your%20issue%20content%20here."
   class="headerbtn"
   data-toggle="tooltip"
data-placement="left"
title="Open an issue"
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-lightbulb"></i>
  </span>
<span class="headerbtn__text-container">open issue</span>
</a>

      </li>
      
    </ul>
  </div>
</div>

<div class="menu-dropdown menu-dropdown-download-buttons">
  <button class="headerbtn menu-dropdown__trigger"
      aria-label="Download this page">
      <i class="fas fa-download"></i>
  </button>
  <div class="menu-dropdown__content">
    <ul>
      <li>
        <a href="../_sources/algos/all_algos.ipynb"
   class="headerbtn"
   data-toggle="tooltip"
data-placement="left"
title="Download source file"
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-file"></i>
  </span>
<span class="headerbtn__text-container">.ipynb</span>
</a>

      </li>
      
      <li>
        
<button onclick="printPdf(this)"
  class="headerbtn"
  data-toggle="tooltip"
data-placement="left"
title="Print to PDF"
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-file-pdf"></i>
  </span>
<span class="headerbtn__text-container">.pdf</span>
</button>

      </li>
      
    </ul>
  </div>
</div>
<label for="__page-toc"
  class="headerbtn headerbtn-page-toc"
  
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-list"></i>
  </span>

</label>

    </div>
</div>

<!-- Table of contents -->
<div class="col-md-3 bd-toc show noprint">
    <div class="tocsection onthispage pt-5 pb-3">
        <i class="fas fa-list"></i> Contents
    </div>
    <nav id="bd-toc-nav" aria-label="Page">
        <ul class="visible nav section-nav flex-column">
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#number-of-solved-problems">
   Number of solved problems
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#python">
   Python
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#arrays">
     Arrays
    </a>
    <ul class="nav section-nav flex-column">
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#two-sum">
       Two sum
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#three-sum">
       Three sum
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#longest-substring-without-repeating-characters">
       Longest substring without repeating characters
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#median-of-two-sorted-arrays">
       Median of Two Sorted Arrays
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#container-with-most-water">
       Container with most water
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#three-sum-closet">
       Three sum closet
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#next-permutation">
       Next Permutation
      </a>
     </li>
    </ul>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#graph">
     Graph
    </a>
    <ul class="nav section-nav flex-column">
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#adjacency-list">
       Adjacency list
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#disjoint-sets-quick-find">
       Disjoint sets - Quick find
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#disjoint-sets-quick-union">
       Disjoint sets - Quick union
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#disjoint-sets-union-by-rank">
       Disjoint sets - Union by rank
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#disjoint-sets-path-compression-optimization">
       Disjoint Sets - Path Compression Optimization
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#valid-graph-tree">
       Valid Graph Tree
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#dfs-depth-first-search">
       DFS - Depth-first search
      </a>
      <ul class="nav section-nav flex-column">
       <li class="toc-h5 nav-item toc-entry">
        <a class="reference internal nav-link" href="#dfs-iterative-depth-first-search">
         DFS - Iterative depth-first search
        </a>
       </li>
      </ul>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#dfs-find-if-path-exists-in-graph">
       DFS - Find if path exists in graph
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#dfs-possible-paths-in-dag">
       DFS - Possible paths in DAG
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#bfs-breadth-first-search">
       BFS - Breadth-first search
      </a>
     </li>
    </ul>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#dp">
     DP
    </a>
    <ul class="nav section-nav flex-column">
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#longest-common-subsequence">
       Longest Common Subsequence
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#fibonacci-number-6-ways">
       Fibonacci number - 6 ways
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#climbing-stairs-basic-scenario">
       Climbing stairs - Basic scenario
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#climbing-stairs-minimum">
       Climbing stairs - minimum
      </a>
     </li>
    </ul>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#codechef-codeforces">
     CodeChef/CodeForces
    </a>
    <ul class="nav section-nav flex-column">
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#good-pairs">
       Good Pairs
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#most-similar-words">
       Most Similar Words
      </a>
     </li>
    </ul>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#c">
   C++
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#sliding-window">
     Sliding Window
    </a>
    <ul class="nav section-nav flex-column">
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#average-of-subarray-of-m-elements-brute-force">
       Average of subarray of m elements (Brute force)
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#average-of-subarray-of-m-elements-sliding-window">
       Average of subarray of m elements (Sliding Window)
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#longest-substring-with-k-distinct-characters">
       Longest substring with k distinct characters
      </a>
     </li>
    </ul>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#two-pointers">
     Two pointers
    </a>
    <ul class="nav section-nav flex-column">
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#remove-duplicates">
       Remove duplicates
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#square-sorted-array">
       Square sorted array
      </a>
     </li>
    </ul>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#fast-and-slow-pointers">
     Fast and Slow Pointers
    </a>
    <ul class="nav section-nav flex-column">
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#linked-list-cycle">
       Linked List Cycle
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#head-of-the-linked-list-cycle">
       Head of the linked list cycle
      </a>
     </li>
    </ul>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#merge-intervals">
     Merge Intervals
    </a>
    <ul class="nav section-nav flex-column">
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#id1">
       Merge Intervals
      </a>
     </li>
    </ul>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#todo">
     TODO
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#codeforces">
     CodeForces
    </a>
    <ul class="nav section-nav flex-column">
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#id2">
       Most Similar Words
      </a>
     </li>
    </ul>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#java">
   Java
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#codechef">
     CodeChef
    </a>
    <ul class="nav section-nav flex-column">
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#goodpairs">
       GoodPairs
      </a>
     </li>
    </ul>
   </li>
  </ul>
 </li>
</ul>

    </nav>
</div>
    </div>
    <div class="article row">
        <div class="col pl-md-3 pl-lg-5 content-container">
            <!-- Table of contents that is only displayed when printing the page -->
            <div id="jb-print-docs-body" class="onlyprint">
                <h1>Coding Challenges</h1>
                <!-- Table of contents -->
                <div id="print-main-content">
                    <div id="jb-print-toc">
                        
                        <div>
                            <h2> Contents </h2>
                        </div>
                        <nav aria-label="Page">
                            <ul class="visible nav section-nav flex-column">
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#number-of-solved-problems">
   Number of solved problems
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#python">
   Python
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#arrays">
     Arrays
    </a>
    <ul class="nav section-nav flex-column">
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#two-sum">
       Two sum
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#three-sum">
       Three sum
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#longest-substring-without-repeating-characters">
       Longest substring without repeating characters
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#median-of-two-sorted-arrays">
       Median of Two Sorted Arrays
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#container-with-most-water">
       Container with most water
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#three-sum-closet">
       Three sum closet
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#next-permutation">
       Next Permutation
      </a>
     </li>
    </ul>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#graph">
     Graph
    </a>
    <ul class="nav section-nav flex-column">
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#adjacency-list">
       Adjacency list
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#disjoint-sets-quick-find">
       Disjoint sets - Quick find
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#disjoint-sets-quick-union">
       Disjoint sets - Quick union
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#disjoint-sets-union-by-rank">
       Disjoint sets - Union by rank
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#disjoint-sets-path-compression-optimization">
       Disjoint Sets - Path Compression Optimization
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#valid-graph-tree">
       Valid Graph Tree
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#dfs-depth-first-search">
       DFS - Depth-first search
      </a>
      <ul class="nav section-nav flex-column">
       <li class="toc-h5 nav-item toc-entry">
        <a class="reference internal nav-link" href="#dfs-iterative-depth-first-search">
         DFS - Iterative depth-first search
        </a>
       </li>
      </ul>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#dfs-find-if-path-exists-in-graph">
       DFS - Find if path exists in graph
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#dfs-possible-paths-in-dag">
       DFS - Possible paths in DAG
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#bfs-breadth-first-search">
       BFS - Breadth-first search
      </a>
     </li>
    </ul>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#dp">
     DP
    </a>
    <ul class="nav section-nav flex-column">
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#longest-common-subsequence">
       Longest Common Subsequence
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#fibonacci-number-6-ways">
       Fibonacci number - 6 ways
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#climbing-stairs-basic-scenario">
       Climbing stairs - Basic scenario
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#climbing-stairs-minimum">
       Climbing stairs - minimum
      </a>
     </li>
    </ul>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#codechef-codeforces">
     CodeChef/CodeForces
    </a>
    <ul class="nav section-nav flex-column">
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#good-pairs">
       Good Pairs
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#most-similar-words">
       Most Similar Words
      </a>
     </li>
    </ul>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#c">
   C++
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#sliding-window">
     Sliding Window
    </a>
    <ul class="nav section-nav flex-column">
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#average-of-subarray-of-m-elements-brute-force">
       Average of subarray of m elements (Brute force)
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#average-of-subarray-of-m-elements-sliding-window">
       Average of subarray of m elements (Sliding Window)
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#longest-substring-with-k-distinct-characters">
       Longest substring with k distinct characters
      </a>
     </li>
    </ul>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#two-pointers">
     Two pointers
    </a>
    <ul class="nav section-nav flex-column">
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#remove-duplicates">
       Remove duplicates
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#square-sorted-array">
       Square sorted array
      </a>
     </li>
    </ul>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#fast-and-slow-pointers">
     Fast and Slow Pointers
    </a>
    <ul class="nav section-nav flex-column">
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#linked-list-cycle">
       Linked List Cycle
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#head-of-the-linked-list-cycle">
       Head of the linked list cycle
      </a>
     </li>
    </ul>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#merge-intervals">
     Merge Intervals
    </a>
    <ul class="nav section-nav flex-column">
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#id1">
       Merge Intervals
      </a>
     </li>
    </ul>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#todo">
     TODO
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#codeforces">
     CodeForces
    </a>
    <ul class="nav section-nav flex-column">
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#id2">
       Most Similar Words
      </a>
     </li>
    </ul>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#java">
   Java
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#codechef">
     CodeChef
    </a>
    <ul class="nav section-nav flex-column">
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#goodpairs">
       GoodPairs
      </a>
     </li>
    </ul>
   </li>
  </ul>
 </li>
</ul>

                        </nav>
                    </div>
                </div>
            </div>
            <main id="main-content" role="main">
                
              <div>
                
  <section class="tex2jax_ignore mathjax_ignore" id="coding-challenges">
<h1>Coding Challenges<a class="headerlink" href="#coding-challenges" title="Permalink to this headline">#</a></h1>
<section id="number-of-solved-problems">
<h2>Number of solved problems<a class="headerlink" href="#number-of-solved-problems" title="Permalink to this headline">#</a></h2>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="o">!</span>grep -o <span class="s1">&#39;%load&#39;</span> all_algos.ipynb <span class="p">|</span> wc -l
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>      32
</pre></div>
</div>
</div>
</div>
</section>
<section id="python">
<h2>Python<a class="headerlink" href="#python" title="Permalink to this headline">#</a></h2>
<section id="arrays">
<h3>Arrays<a class="headerlink" href="#arrays" title="Permalink to this headline">#</a></h3>
<section id="two-sum">
<h4>Two sum<a class="headerlink" href="#two-sum" title="Permalink to this headline">#</a></h4>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># %load ./pycharm/arrays/two_sum.py</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Given an array of integers, return indices of the two numbers</span>
<span class="sd">such that they add up to a specific target.</span>

<span class="sd">You may assume that each input would have exactly one solution,</span>
<span class="sd">and you may not use the same element twice.</span>

<span class="sd">Example:</span>
<span class="sd">    Given nums = [2, 7, 11, 15], target = 9,</span>

<span class="sd">    Because nums[0] + nums[1] = 2 + 7 = 9,</span>
<span class="sd">    return (0, 1)</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="k">def</span> <span class="nf">sumMethod</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">target</span><span class="p">):</span>
    <span class="n">dic</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">array</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">dic</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">(</span><span class="n">dic</span><span class="p">[</span><span class="n">value</span><span class="p">],</span> <span class="n">index</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">dic</span><span class="p">[</span><span class="n">target</span> <span class="o">-</span> <span class="n">value</span><span class="p">]</span> <span class="o">=</span> <span class="n">index</span>
    <span class="k">return</span> <span class="kc">None</span>


<span class="n">array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">11</span><span class="p">,</span> <span class="mi">9</span><span class="p">])</span>
<span class="n">target</span> <span class="o">=</span> <span class="mi">11</span>
<span class="nb">print</span><span class="p">(</span><span class="n">sumMethod</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">target</span><span class="p">))</span>
<span class="n">target</span> <span class="o">=</span> <span class="mi">10</span>
<span class="nb">print</span><span class="p">(</span><span class="n">sumMethod</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">target</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>(0, 3)
None
</pre></div>
</div>
</div>
</div>
</section>
<section id="three-sum">
<h4>Three sum<a class="headerlink" href="#three-sum" title="Permalink to this headline">#</a></h4>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># %load ./pycharm/arrays/three_sum.py</span>
<span class="kn">from</span> <span class="nn">itertools</span> <span class="kn">import</span> <span class="n">combinations</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Given an array S of n integers, are there three distinct elements</span>
<span class="sd">a, b, c in S such that a + b + c = 0?</span>
<span class="sd">Find all unique triplets in the array which gives the sum of zero.</span>

<span class="sd">Note: The solution set must not contain duplicate triplets.</span>

<span class="sd">For example, given array S = [-1, 0, 1, 2, -1, -4],</span>

<span class="sd">A solution set is:</span>
<span class="sd">{</span>
<span class="sd">  (-1, 0, 1),</span>
<span class="sd">  (-1, -1, 2)</span>
<span class="sd">}</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="k">def</span> <span class="nf">three_sum</span><span class="p">(</span><span class="n">array</span><span class="p">):</span>
    <span class="c1"># combs = set([tuple(sorted(t)) for t in combinations(array, 3)])</span>
    <span class="c1"># result = {item for item in combs if sum(item) == 0}</span>
    <span class="n">result</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([</span><span class="nb">tuple</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">t</span><span class="p">))</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">combinations</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span> <span class="k">if</span> <span class="nb">sum</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">result</span>

<span class="n">array</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">4</span><span class="p">]</span>
<span class="nb">print</span><span class="p">(</span><span class="n">three_sum</span><span class="p">(</span><span class="n">array</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>{(-1, 0, 1), (-1, -1, 2)}
</pre></div>
</div>
</div>
</div>
</section>
<section id="longest-substring-without-repeating-characters">
<h4>Longest substring without repeating characters<a class="headerlink" href="#longest-substring-without-repeating-characters" title="Permalink to this headline">#</a></h4>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># %load ./pycharm/arrays/longest_substring_wo_repeat.py</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Given a string, find the length of the longest substring</span>
<span class="sd">without repeating characters.</span>

<span class="sd">Examples:</span>
<span class="sd">Given &quot;abcabcbb&quot;, the answer is &quot;abc&quot;, which the length is 3.</span>
<span class="sd">Given &quot;bbbbb&quot;, the answer is &quot;b&quot;, with the length of 1.</span>
<span class="sd">Given &quot;pwwkew&quot;, the answer is &quot;wke&quot;, with the length of 3.</span>
<span class="sd">Note that the answer must be a substring,</span>
<span class="sd">&quot;pwke&quot; is a subsequence and not a substring.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="k">def</span> <span class="nf">mainFun</span><span class="p">(</span><span class="n">string</span><span class="p">):</span>
    <span class="n">str_arr</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">string</span><span class="p">)</span>
    <span class="n">str_len</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">str_arr</span><span class="p">)</span>
    <span class="n">outer_dict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
    <span class="n">inner_dict</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">str_len</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">str_len</span><span class="o">-</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
            <span class="n">sub_str</span> <span class="o">=</span> <span class="n">str_arr</span><span class="p">[</span><span class="n">j</span><span class="p">:</span><span class="n">j</span><span class="o">+</span><span class="n">i</span><span class="p">]</span>
            <span class="n">tup</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">sub_str</span><span class="p">)))</span>
            <span class="k">if</span> <span class="n">tup</span> <span class="ow">in</span> <span class="n">inner_dict</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
                <span class="c1"># print(f&quot;Duplicate={&#39;&#39;.join(sub_str)}: {tup}&quot;)</span>
                <span class="k">break</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">str2</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">sub_str</span><span class="p">)</span>
                <span class="n">inner_dict</span><span class="p">[</span><span class="n">str2</span><span class="p">]</span> <span class="o">=</span> <span class="n">tup</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">inner_dict</span><span class="p">)</span>

    <span class="n">max_length</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">element</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">for</span> <span class="n">k</span><span class="p">,</span><span class="n">v</span> <span class="ow">in</span> <span class="n">inner_dict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">max_length</span><span class="p">:</span>
            <span class="n">max_length</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
            <span class="n">element</span> <span class="o">=</span> <span class="n">k</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">element</span><span class="p">))</span>


<span class="n">string</span> <span class="o">=</span> <span class="s2">&quot;abcabcbb&quot;</span>
<span class="n">mainFun</span><span class="p">(</span><span class="n">string</span><span class="p">)</span>
<span class="n">string</span> <span class="o">=</span> <span class="s2">&quot;bbbbb&quot;</span>
<span class="n">mainFun</span><span class="p">(</span><span class="n">string</span><span class="p">)</span>
<span class="n">string</span> <span class="o">=</span> <span class="s2">&quot;pwwkew&quot;</span>
<span class="n">mainFun</span><span class="p">(</span><span class="n">string</span><span class="p">)</span> <span class="c1"># Not working right</span>
<span class="n">string</span> <span class="o">=</span> <span class="s2">&quot;abcdefg&quot;</span>
<span class="n">mainFun</span><span class="p">(</span><span class="n">string</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>{&#39;a&#39;: (&#39;a&#39;,), &#39;b&#39;: (&#39;b&#39;,), &#39;c&#39;: (&#39;c&#39;,), &#39;ab&#39;: (&#39;a&#39;, &#39;b&#39;), &#39;bc&#39;: (&#39;b&#39;, &#39;c&#39;), &#39;ca&#39;: (&#39;a&#39;, &#39;c&#39;), &#39;abc&#39;: (&#39;a&#39;, &#39;b&#39;, &#39;c&#39;)}
abc
{&#39;b&#39;: (&#39;b&#39;,)}
b
{&#39;p&#39;: (&#39;p&#39;,), &#39;w&#39;: (&#39;w&#39;,), &#39;pw&#39;: (&#39;p&#39;, &#39;w&#39;), &#39;pwwk&#39;: (&#39;k&#39;, &#39;p&#39;, &#39;w&#39;), &#39;wwke&#39;: (&#39;e&#39;, &#39;k&#39;, &#39;w&#39;), &#39;pwwke&#39;: (&#39;e&#39;, &#39;k&#39;, &#39;p&#39;, &#39;w&#39;)}
pwwke
{&#39;a&#39;: (&#39;a&#39;,), &#39;b&#39;: (&#39;b&#39;,), &#39;c&#39;: (&#39;c&#39;,), &#39;d&#39;: (&#39;d&#39;,), &#39;e&#39;: (&#39;e&#39;,), &#39;f&#39;: (&#39;f&#39;,), &#39;g&#39;: (&#39;g&#39;,), &#39;ab&#39;: (&#39;a&#39;, &#39;b&#39;), &#39;bc&#39;: (&#39;b&#39;, &#39;c&#39;), &#39;cd&#39;: (&#39;c&#39;, &#39;d&#39;), &#39;de&#39;: (&#39;d&#39;, &#39;e&#39;), &#39;ef&#39;: (&#39;e&#39;, &#39;f&#39;), &#39;fg&#39;: (&#39;f&#39;, &#39;g&#39;), &#39;abc&#39;: (&#39;a&#39;, &#39;b&#39;, &#39;c&#39;), &#39;bcd&#39;: (&#39;b&#39;, &#39;c&#39;, &#39;d&#39;), &#39;cde&#39;: (&#39;c&#39;, &#39;d&#39;, &#39;e&#39;), &#39;def&#39;: (&#39;d&#39;, &#39;e&#39;, &#39;f&#39;), &#39;efg&#39;: (&#39;e&#39;, &#39;f&#39;, &#39;g&#39;), &#39;abcd&#39;: (&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;), &#39;bcde&#39;: (&#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;), &#39;cdef&#39;: (&#39;c&#39;, &#39;d&#39;, &#39;e&#39;, &#39;f&#39;), &#39;defg&#39;: (&#39;d&#39;, &#39;e&#39;, &#39;f&#39;, &#39;g&#39;), &#39;abcde&#39;: (&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;), &#39;bcdef&#39;: (&#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;, &#39;f&#39;), &#39;cdefg&#39;: (&#39;c&#39;, &#39;d&#39;, &#39;e&#39;, &#39;f&#39;, &#39;g&#39;), &#39;abcdef&#39;: (&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;, &#39;f&#39;), &#39;bcdefg&#39;: (&#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;, &#39;f&#39;, &#39;g&#39;), &#39;abcdefg&#39;: (&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;, &#39;f&#39;, &#39;g&#39;)}
abcdefg
</pre></div>
</div>
</div>
</div>
</section>
<section id="median-of-two-sorted-arrays">
<h4>Median of Two Sorted Arrays<a class="headerlink" href="#median-of-two-sorted-arrays" title="Permalink to this headline">#</a></h4>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># %load ./pycharm/arrays/median_sorted_array.py</span>
<span class="k">class</span> <span class="nc">Solution</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Given two sorted arrays nums1 and nums2 of size m and n respectively, return the median of the two sorted arrays.</span>

<span class="sd">    The overall run time complexity should be O(log (m+n)).</span>

<span class="sd">    Example 1:</span>

<span class="sd">    Input: nums1 = [1,3], nums2 = [2]</span>
<span class="sd">    Output: 2.00000</span>
<span class="sd">    Explanation: merged array = [1,2,3] and median is 2.</span>
<span class="sd">    Example 2:</span>

<span class="sd">    Input: nums1 = [1,2], nums2 = [3,4]</span>
<span class="sd">    Output: 2.50000</span>
<span class="sd">    Explanation: merged array = [1,2,3,4] and median is (2 + 3) / 2 = 2.5.</span>


<span class="sd">    Constraints:</span>

<span class="sd">    nums1.length == m</span>
<span class="sd">    nums2.length == n</span>
<span class="sd">    0 &lt;= m &lt;= 1000</span>
<span class="sd">    0 &lt;= n &lt;= 1000</span>
<span class="sd">    1 &lt;= m + n &lt;= 2000</span>
<span class="sd">    -106 &lt;= nums1[i], nums2[i] &lt;= 106</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">def</span> <span class="nf">findMedianSortedArrays</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nums1</span><span class="p">,</span> <span class="n">nums2</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :type nums1: List[int]</span>
<span class="sd">        :type nums2: List[int]</span>
<span class="sd">        :rtype: float</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">l1</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">nums1</span><span class="p">)</span>
        <span class="n">l2</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">nums2</span><span class="p">)</span>
        <span class="n">i1</span><span class="p">,</span> <span class="n">i2</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span>
        <span class="n">snums</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">i1</span> <span class="o">&lt;</span> <span class="n">l1</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">i2</span> <span class="o">&lt;</span> <span class="n">l2</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">nums1</span><span class="p">[</span><span class="n">i1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">nums2</span><span class="p">[</span><span class="n">i2</span><span class="p">]:</span>
                <span class="n">snums</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">nums1</span><span class="p">[</span><span class="n">i1</span><span class="p">])</span>
                <span class="n">i1</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">snums</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">nums2</span><span class="p">[</span><span class="n">i2</span><span class="p">])</span>
                <span class="n">i2</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">i1</span> <span class="o">&lt;</span> <span class="n">l1</span><span class="p">:</span>
            <span class="n">snums</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">nums1</span><span class="p">[</span><span class="n">i1</span><span class="p">:])</span>
        <span class="k">if</span> <span class="n">i2</span> <span class="o">&lt;</span> <span class="n">l2</span><span class="p">:</span>
            <span class="n">snums</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">nums2</span><span class="p">[</span><span class="n">i2</span><span class="p">:])</span>

        <span class="n">median</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">snums</span><span class="p">:</span>
            <span class="n">mid</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">snums</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">snums</span><span class="p">)</span> <span class="o">%</span> <span class="mi">2</span><span class="p">:</span>
                <span class="n">median</span> <span class="o">=</span> <span class="n">snums</span><span class="p">[</span><span class="n">mid</span><span class="p">]</span> <span class="c1"># Odd</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">median</span> <span class="o">=</span> <span class="p">(</span><span class="n">snums</span><span class="p">[</span><span class="n">mid</span><span class="p">]</span> <span class="o">+</span> <span class="n">snums</span><span class="p">[</span><span class="n">mid</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span><span class="o">/</span><span class="mi">2</span> <span class="c1"># Even</span>

        <span class="k">return</span> <span class="n">median</span>

<span class="n">s</span> <span class="o">=</span> <span class="n">Solution</span><span class="p">()</span>
<span class="n">nums1</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span>
<span class="n">nums2</span> <span class="o">=</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">]</span>
<span class="nb">print</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">findMedianSortedArrays</span><span class="p">(</span><span class="n">nums1</span><span class="p">,</span> <span class="n">nums2</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>2.5
</pre></div>
</div>
</div>
</div>
</section>
<section id="container-with-most-water">
<h4>Container with most water<a class="headerlink" href="#container-with-most-water" title="Permalink to this headline">#</a></h4>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># %load ./pycharm/arrays/container_with_most_water.py</span>
<span class="k">class</span> <span class="nc">Solution</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    You are given an integer array height of length n. There are n vertical lines drawn such that the two endpoints</span>
<span class="sd">    of the ith line are (i, 0) and (i, height[i]).</span>

<span class="sd">    Find two lines that together with the x-axis form a container, such that the container contains the most water.</span>

<span class="sd">    Return the maximum amount of water a container can store.</span>

<span class="sd">    Notice that you may not slant the container.</span>

<span class="sd">    Example 1:</span>

<span class="sd">    Input: height = [1,8,6,2,5,4,8,3,7]</span>
<span class="sd">    Output: 49</span>
<span class="sd">    Explanation: The above vertical lines are represented by array [1,8,6,2,5,4,8,3,7]. In this case, the max area of</span>
<span class="sd">    water (blue section) the container can contain is 49.</span>
<span class="sd">    Example 2:</span>

<span class="sd">    Input: height = [1,1]</span>
<span class="sd">    Output: 1</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">def</span> <span class="nf">maxArea</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">height</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :type height: List[int]</span>
<span class="sd">        :rtype: int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">l</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">r</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">height</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span>
        <span class="n">xArea</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">while</span> <span class="n">l</span> <span class="o">&lt;</span> <span class="n">r</span><span class="p">:</span>
            <span class="n">xArea</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">xArea</span><span class="p">,</span> <span class="nb">min</span><span class="p">(</span><span class="n">height</span><span class="p">[</span><span class="n">l</span><span class="p">],</span> <span class="n">height</span><span class="p">[</span><span class="n">r</span><span class="p">])</span> <span class="o">*</span> <span class="p">(</span><span class="n">r</span> <span class="o">-</span> <span class="n">l</span><span class="p">))</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">height</span><span class="p">[</span><span class="n">l</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">height</span><span class="p">[</span><span class="n">r</span><span class="p">]):</span>
                <span class="n">l</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">r</span> <span class="o">-=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">xArea</span>

<span class="n">s</span> <span class="o">=</span> <span class="n">Solution</span><span class="p">()</span>
<span class="n">height</span> <span class="o">=</span>  <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">7</span><span class="p">]</span>
<span class="nb">print</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">maxArea</span><span class="p">(</span><span class="n">height</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>49
</pre></div>
</div>
</div>
</div>
</section>
<section id="three-sum-closet">
<h4>Three sum closet<a class="headerlink" href="#three-sum-closet" title="Permalink to this headline">#</a></h4>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># %load ./pycharm/arrays/three_sum_closet.py</span>
<span class="kn">from</span> <span class="nn">itertools</span> <span class="kn">import</span> <span class="n">combinations</span>

<span class="k">class</span> <span class="nc">Solution</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Given an integer array nums of length n and an integer target, find three integers in nums such that the</span>
<span class="sd">    sum is closest to target.</span>

<span class="sd">    Return the sum of the three integers.</span>

<span class="sd">    You may assume that each input would have exactly one solution.</span>

<span class="sd">    Example 1:</span>
<span class="sd">        Input: nums = [-1,2,1,-4], target = 1</span>
<span class="sd">        Output: 2</span>
<span class="sd">        Explanation: The sum that is closest to the target is 2. (-1 + 2 + 1 = 2).</span>

<span class="sd">    Example 2:</span>
<span class="sd">        Input: nums = [0,0,0], target = 1</span>
<span class="sd">        Output: 0</span>

<span class="sd">    Constraints:</span>
<span class="sd">         3 &lt;= nums.length &lt;= 1000</span>
<span class="sd">        -1000 &lt;= nums[i] &lt;= 1000</span>
<span class="sd">        -10^4 &lt;= target &lt;= 10^4</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">def</span> <span class="nf">threeSumClosest</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nums</span><span class="p">,</span> <span class="n">target</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :type nums: List[int]</span>
<span class="sd">        :type target: int</span>
<span class="sd">        :rtype: int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># combs = [elements for elements in combinations(nums, 3)]</span>
        <span class="c1"># difference = [abs(target - sum(elements)) for elements in combs]</span>
        <span class="c1"># print(combs, difference)</span>
        <span class="c1"># return sum(combs[difference.index(min(difference))])</span>

        <span class="n">overall_sum</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="s1">&#39;inf&#39;</span><span class="p">)</span>
        <span class="n">nums</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)):</span>
            <span class="n">l</span><span class="p">,</span> <span class="n">h</span> <span class="o">=</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span>
            <span class="k">while</span><span class="p">(</span><span class="n">l</span> <span class="o">&lt;</span> <span class="n">h</span><span class="p">):</span>
                <span class="n">local_sum</span> <span class="o">=</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">nums</span><span class="p">[</span><span class="n">l</span><span class="p">]</span> <span class="o">+</span> <span class="n">nums</span><span class="p">[</span><span class="n">h</span><span class="p">]</span>
                <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">target</span> <span class="o">-</span> <span class="n">local_sum</span><span class="p">)</span> <span class="o">&lt;</span> <span class="nb">abs</span><span class="p">(</span><span class="n">overall_sum</span><span class="p">):</span>
                    <span class="n">overall_sum</span> <span class="o">=</span> <span class="n">target</span> <span class="o">-</span> <span class="n">local_sum</span>
                <span class="k">if</span> <span class="n">local_sum</span> <span class="o">&lt;</span> <span class="n">target</span><span class="p">:</span>
                    <span class="n">l</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">h</span> <span class="o">-=</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="n">overall_sum</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">break</span>
        <span class="k">return</span> <span class="n">target</span> <span class="o">-</span> <span class="n">overall_sum</span>


<span class="n">s</span> <span class="o">=</span> <span class="n">Solution</span><span class="p">()</span>
<span class="c1"># nums = [-86,8,0,-79,-23,88,-26,-17,41,70,1,29,3,-52,-30,-31,14,42,4,-52,-77,-39,91,-13,98,41,-16,-8,91,54,50,1,-22,45,30,20,-36,-41,-48,-25,-3,76,69,-38,78,-45,-75,-57,55,-23,65,-23,69,60,85,-95,84,-73,-21,43,35,58,66,6,-49,38,-5,46,-24,23,-23,63,55,-91,80,-73,-53,24,-77,-5,-93,4,2,-71,23,2,-44,-19,33,73,9,-94,41,81,-14,43,27,3,-65,-89,0,-100,-89,-76,95,0,-60,65,-77,85,-29,98,-8,18,41,-93,-64,51,-77,-39,-75,-6,-65,0,-15,66,80,67,-96,26,-57,-43,-76,72,20,-55,-83,95,-65,22,-47,-90,-83,13,6,81,-23,-50,-17,17,100,99,66,-62,-21,76,37,60,-88,64,78,-90,67,-65,-62,55,-87,-75,-79,14,87,-100,-87,9,-98,0,-83,7,29,33,-87,-50,6,-57,28,17,26,4]</span>
<span class="c1"># target = 136</span>
<span class="n">nums</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>
<span class="n">target</span> <span class="o">=</span> <span class="o">-</span><span class="mi">100</span>
<span class="c1"># nums = [-1,2,1,-4]</span>
<span class="c1"># target = 1</span>
<span class="nb">print</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">threeSumClosest</span><span class="p">(</span><span class="n">nums</span><span class="p">,</span> <span class="n">target</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>2
</pre></div>
</div>
</div>
</div>
</section>
<section id="next-permutation">
<h4>Next Permutation<a class="headerlink" href="#next-permutation" title="Permalink to this headline">#</a></h4>
<p align="center"><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/1/1c/Orderings%3B_6_choose_3.svg/680px-Orderings%3B_6_choose_3.svg.png" width=300 height=400></p><div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># %load ./pycharm/arrays/next_permutation.py</span>
<span class="k">class</span> <span class="nc">Solution</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    A permutation of an array of integers is an arrangement of its members into a sequence or linear order.</span>

<span class="sd">    For example, for arr = [1,2,3], the following are considered permutations of arr: [1,2,3], [1,3,2], [3,1,2],</span>
<span class="sd">    [2,3,1].</span>
<span class="sd">    The next permutation of an array of integers is the next lexicographically greater permutation of its integer.</span>
<span class="sd">    More formally, if all the permutations of the array are sorted in one container according to their</span>
<span class="sd">    lexicographical order, then the next permutation of that array is the permutation that follows it in the</span>
<span class="sd">    sorted container. If such arrangement is not possible, the array must be rearranged as the lowest possible</span>
<span class="sd">    order (i.e., sorted in ascending order).</span>

<span class="sd">    For example, the next permutation of arr = [1,2,3] is [1,3,2].</span>
<span class="sd">    Similarly, the next permutation of arr = [2,3,1] is [3,1,2].</span>
<span class="sd">    While the next permutation of arr = [3,2,1] is [1,2,3] because [3,2,1] does not have a lexicographical larger</span>
<span class="sd">    rearrangement.</span>
<span class="sd">    Given an array of integers nums, find the next permutation of nums.</span>

<span class="sd">    The replacement must be in place and use only constant extra memory.</span>

<span class="sd">    Example 1:</span>
<span class="sd">        Input: nums = [1,2,3]</span>
<span class="sd">        Output: [1,3,2]</span>
<span class="sd">    Example 2:</span>
<span class="sd">        Input: nums = [3,2,1]</span>
<span class="sd">        Output: [1,2,3]</span>
<span class="sd">    Example 3:</span>
<span class="sd">        Input: nums = [1,1,5]</span>
<span class="sd">        Output: [1,5,1]</span>

<span class="sd">    Constraints:</span>
<span class="sd">        1 &lt;= nums.length &lt;= 100</span>
<span class="sd">        0 &lt;= nums[i] &lt;= 100</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">def</span> <span class="nf">nextPermutation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nums</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :type nums: List[int]</span>
<span class="sd">        :rtype: None Do not return anything, modify nums in-place instead.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># 1 2 3 -&gt; 1 3 2</span>
        <span class="c1"># 3 2 1 -&gt; 1 2 3</span>
        <span class="c1"># 1 1 5 -&gt; 1 5 1</span>
        <span class="c1"># 1 3 5 4 3 2 1 -&gt; 1 4 1 2 3 3 5</span>

        <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span>
        <span class="n">pivot</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="c1"># find pivot &quot;position&quot;- loop from back to front, to check if previous element is smaller than next</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
                <span class="n">pivot</span> <span class="o">=</span> <span class="n">i</span>
                <span class="k">break</span>

        <span class="c1"># if array is in descending order, sort them, and return</span>
        <span class="k">if</span> <span class="n">pivot</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">nums</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
            <span class="k">return</span>

        <span class="c1"># find pivot &quot;element&quot; among element from pivot to the end(next lexicographical element)</span>
        <span class="n">swap</span> <span class="o">=</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="k">while</span><span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="n">pivot</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">nums</span><span class="p">[</span><span class="n">swap</span><span class="p">]):</span>
            <span class="n">swap</span> <span class="o">-=</span> <span class="mi">1</span>

        <span class="c1"># swap &quot;pivot element&quot; with next &quot;lexicographical element&quot;, and then sort all elements post pivot</span>
        <span class="n">nums</span><span class="p">[</span><span class="n">swap</span><span class="p">],</span> <span class="n">nums</span><span class="p">[</span><span class="n">pivot</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">nums</span><span class="p">[</span><span class="n">pivot</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">nums</span><span class="p">[</span><span class="n">swap</span><span class="p">]</span>
        <span class="n">nums</span><span class="p">[</span><span class="n">pivot</span><span class="p">:]</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="n">pivot</span><span class="p">:])</span>
        <span class="k">return</span>

<span class="n">s</span> <span class="o">=</span> <span class="n">Solution</span><span class="p">()</span>
<span class="n">nums</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
<span class="c1"># nums = [1,1,5]</span>
<span class="n">s</span><span class="o">.</span><span class="n">nextPermutation</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>[1, 4, 1, 2, 3, 3, 5]
</pre></div>
</div>
</div>
</div>
</section>
</section>
<section id="graph">
<h3>Graph<a class="headerlink" href="#graph" title="Permalink to this headline">#</a></h3>
<section id="adjacency-list">
<h4>Adjacency list<a class="headerlink" href="#adjacency-list" title="Permalink to this headline">#</a></h4>
<ul class="simple">
<li><p>useful in sparsely connected graphs</p></li>
<li><p>space complexity O(V+E)</p></li>
</ul>
<p align="center"><img src="images/adjacency_list.png" width=400 height=400> </p> <div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># %load ./pycharm/graphs/adjacency_list.py</span>
<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">Add two container - one vertex, another graph object</span>
<span class="sd">vertex - holds node and neighbors information</span>
<span class="sd">graph - holds adds all vertices, edge/connection information</span>
<span class="sd">&#39;&#39;&#39;</span>

<span class="k">class</span> <span class="nc">Vertex</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vertex</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">vertex</span> <span class="o">=</span> <span class="n">vertex</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">neighbors</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="k">def</span> <span class="nf">addNeighbor</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vertex</span><span class="p">,</span> <span class="n">edgeValue</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">neighbors</span><span class="p">[</span><span class="n">vertex</span><span class="p">]</span> <span class="o">=</span> <span class="n">edgeValue</span>

    <span class="k">def</span> <span class="nf">getEdges</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">neighbors</span>

    <span class="k">def</span> <span class="nf">getVertex</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">vertex</span>

    <span class="k">def</span> <span class="nf">getEdgeValue</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">neighbors</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">vertex</span><span class="p">]</span>


<span class="k">class</span> <span class="nc">Graph</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">vertices</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="k">def</span> <span class="nf">addVertex</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">vertices</span><span class="p">[</span><span class="n">v</span><span class="o">.</span><span class="n">vertex</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span>

    <span class="k">def</span> <span class="nf">addVertices</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vertexList</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">vertexList</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">addVertex</span><span class="p">(</span><span class="n">Vertex</span><span class="p">(</span><span class="n">i</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">addEdge</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fromToPair</span><span class="p">,</span> <span class="n">edgeValue</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        fromToPair: a tuple pair with &quot;from&quot; vertex information</span>
<span class="sd">                    to &quot;to&quot; vertex information</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">fromToPair</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">fromToPair</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">i</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">vertices</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">addVertex</span><span class="p">(</span><span class="n">Vertex</span><span class="p">(</span><span class="n">i</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">vertices</span><span class="p">[</span><span class="n">fromToPair</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span><span class="o">.</span><span class="n">addNeighbor</span><span class="p">(</span><span class="n">fromToPair</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">edgeValue</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">getVertices</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        This returns all the vertices keys of the graph object</span>
<span class="sd">        :return: vertex keys</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">return</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vertices</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>

    <span class="k">def</span> <span class="nf">getVertexNeighbors</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        This returns vertex neighbor information</span>
<span class="sd">        :param v: vertex object</span>
<span class="sd">        :return: dictionary of neighbor edges</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">vertices</span><span class="p">[</span><span class="n">v</span><span class="o">.</span><span class="n">vertex</span><span class="p">]</span><span class="o">.</span><span class="n">getEdges</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">addGraph</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        An easier way to add elements into graph object</span>
<span class="sd">        The dict parameter holds dictionary of vertices and its dictionary of edge elements</span>
<span class="sd">        :param dict: a two-level nested dictionary, outer holds the vertex, inner holds the edge information</span>
<span class="sd">        :return: None</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span><span class="n">v</span> <span class="ow">in</span> <span class="nb">dict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">addVertex</span><span class="p">(</span><span class="n">Vertex</span><span class="p">(</span><span class="n">k</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">ek</span><span class="p">,</span> <span class="n">ev</span> <span class="ow">in</span> <span class="n">v</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">addEdge</span><span class="p">((</span><span class="n">k</span><span class="p">,</span> <span class="n">ek</span><span class="p">),</span> <span class="n">ev</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">getPossiblePaths</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fromVertex</span><span class="p">,</span> <span class="n">toVertex</span><span class="p">):</span>
        <span class="n">explorePaths</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>

        <span class="c1"># loop over connection universe starting from fromVertex</span>
        <span class="c1"># knocking off the visitedVertex and exploring paths</span>

        <span class="n">numberOfNodes</span> <span class="o">=</span> <span class="mi">2</span>
        <span class="n">root</span> <span class="o">=</span> <span class="n">fromVertex</span>
        <span class="n">neighborSet</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getVertexNeighbors</span><span class="p">(</span><span class="n">root</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">neighborSet</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">explorePaths</span><span class="o">.</span><span class="n">add</span><span class="p">(((</span><span class="n">root</span><span class="o">.</span><span class="n">vertex</span><span class="p">,</span> <span class="n">k</span><span class="p">),</span> <span class="p">(</span><span class="n">v</span><span class="p">,)))</span>

        <span class="n">tempExplorePaths</span> <span class="o">=</span> <span class="n">explorePaths</span>
        <span class="k">while</span><span class="p">(</span><span class="n">explorePaths</span> <span class="ow">and</span> <span class="n">numberOfNodes</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">getVertices</span><span class="p">())):</span>
            <span class="n">explorePaths</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">tempExplorePaths</span><span class="p">:</span>
                <span class="n">l</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getVertexNeighbors</span><span class="p">(</span><span class="n">Vertex</span><span class="p">(</span><span class="n">item</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>
                <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">l</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                    <span class="n">nodes</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">item</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                    <span class="n">weights</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">item</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                    <span class="k">if</span> <span class="n">k</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">nodes</span><span class="p">:</span>
                        <span class="n">nodes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
                        <span class="n">weights</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
                        <span class="n">explorePaths</span><span class="o">.</span><span class="n">add</span><span class="p">(((</span><span class="nb">tuple</span><span class="p">(</span><span class="n">nodes</span><span class="p">),</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">weights</span><span class="p">))))</span>
            <span class="n">tempExplorePaths</span> <span class="o">=</span> <span class="n">explorePaths</span>
            <span class="n">numberOfNodes</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">explorePaths</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">item</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">toVertex</span><span class="o">.</span><span class="n">vertex</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Path=</span><span class="si">{</span><span class="n">item</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s1">, Weight=</span><span class="si">{</span><span class="n">item</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="si">}</span><span class="s1">, Sum=</span><span class="si">{</span><span class="nb">sum</span><span class="p">(</span><span class="n">item</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>



<span class="n">graph</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">()</span>
<span class="n">graphElements</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s1">&#39;a&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;b&#39;</span><span class="p">:</span> <span class="mi">5</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">:</span> <span class="mi">2</span><span class="p">},</span>
    <span class="s1">&#39;b&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;a&#39;</span><span class="p">:</span> <span class="mi">5</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">:</span> <span class="mi">7</span><span class="p">,</span> <span class="s1">&#39;d&#39;</span><span class="p">:</span> <span class="mi">8</span><span class="p">},</span>
    <span class="s1">&#39;c&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;a&#39;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">:</span> <span class="mi">7</span><span class="p">,</span> <span class="s1">&#39;d&#39;</span><span class="p">:</span> <span class="mi">4</span><span class="p">,</span> <span class="s1">&#39;e&#39;</span><span class="p">:</span> <span class="mi">8</span><span class="p">},</span>
    <span class="s1">&#39;d&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;b&#39;</span><span class="p">:</span> <span class="mi">8</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">:</span> <span class="mi">4</span><span class="p">,</span> <span class="s1">&#39;e&#39;</span><span class="p">:</span> <span class="mi">6</span><span class="p">,</span> <span class="s1">&#39;f&#39;</span><span class="p">:</span> <span class="mi">4</span><span class="p">},</span>
    <span class="s1">&#39;e&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;c&#39;</span><span class="p">:</span> <span class="mi">8</span><span class="p">,</span> <span class="s1">&#39;d&#39;</span><span class="p">:</span> <span class="mi">6</span><span class="p">,</span> <span class="s1">&#39;f&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">},</span>
    <span class="s1">&#39;f&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;e&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span> <span class="s1">&#39;d&#39;</span><span class="p">:</span> <span class="mi">4</span><span class="p">}</span>
<span class="p">}</span>
<span class="n">graph</span><span class="o">.</span><span class="n">addGraph</span><span class="p">(</span><span class="n">graphElements</span><span class="p">)</span>
<span class="c1"># print(graph.getVertexNeighbors(Vertex(&#39;a&#39;)))</span>
<span class="n">graph</span><span class="o">.</span><span class="n">getPossiblePaths</span><span class="p">(</span><span class="n">Vertex</span><span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">),</span> <span class="n">Vertex</span><span class="p">(</span><span class="s1">&#39;f&#39;</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Path=(&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;, &#39;f&#39;), Weight=(5, 7, 4, 6, 3), Sum=25
Path=(&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;e&#39;, &#39;d&#39;, &#39;f&#39;), Weight=(5, 7, 8, 6, 4), Sum=30
Path=(&#39;a&#39;, &#39;b&#39;, &#39;d&#39;, &#39;c&#39;, &#39;e&#39;, &#39;f&#39;), Weight=(5, 8, 4, 8, 3), Sum=28
Path=(&#39;a&#39;, &#39;c&#39;, &#39;b&#39;, &#39;d&#39;, &#39;e&#39;, &#39;f&#39;), Weight=(2, 7, 8, 6, 3), Sum=26
</pre></div>
</div>
</div>
</div>
</section>
<section id="disjoint-sets-quick-find">
<h4>Disjoint sets - Quick find<a class="headerlink" href="#disjoint-sets-quick-find" title="Permalink to this headline">#</a></h4>
<ul class="simple">
<li><p>find and union are the important pieces of its implementation</p></li>
<li><p>find method finds the root node of vertex. Time complexity O(1)</p></li>
<li><p>union method combines and makes a common root node. Time complexity O(N)</p></li>
</ul>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># %load ./pycharm/graphs/disjoint_set_01_quick_find.py</span>
<span class="k">class</span> <span class="nc">DisjointSet</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    This implementation is of disjoint set - quick find</span>
<span class="sd">    Hint: Instead of storing parent node in the array, store the root node</span>
<span class="sd">    Then we won&#39;t need iteration from the leaf node to the parent root node</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">size</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rootArr</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">size</span><span class="p">)]</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Arr</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">rootArr</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">find</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Time complexity O(1)</span>
<span class="sd">        Return the element of the corresponding index</span>
<span class="sd">        :param index: index of the array</span>
<span class="sd">        :return: element</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">rootArr</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">union</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nodeOne</span><span class="p">,</span> <span class="n">nodeTwo</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Time complexity O(n)</span>
<span class="sd">        If the elements have a common root, no action is taken.</span>
<span class="sd">        If the elements have different root, the root of node one is assigned to root of node two.</span>
<span class="sd">        :param nodeOne: the first element</span>
<span class="sd">        :param nodeTwo: the second element</span>
<span class="sd">        :return: None</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">rootOne</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="n">nodeOne</span><span class="p">)</span>
        <span class="n">rootTwo</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="n">nodeTwo</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">rootOne</span><span class="p">,</span> <span class="n">rootTwo</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">rootOne</span> <span class="o">!=</span> <span class="n">rootTwo</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rootArr</span><span class="p">)):</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">rootArr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">rootTwo</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">rootArr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">rootOne</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;N1:</span><span class="si">{</span><span class="n">nodeOne</span><span class="si">}</span><span class="s1">, N2:</span><span class="si">{</span><span class="n">nodeTwo</span><span class="si">}</span><span class="s1">, Arr:</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">rootArr</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">isConnected</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nodeOne</span><span class="p">,</span> <span class="n">nodeTwo</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Time complexity O(1)</span>
<span class="sd">        Validates if the root node of element one and element two are same</span>
<span class="sd">        :param nodeOne: node one</span>
<span class="sd">        :param nodeTwo: node two</span>
<span class="sd">        :return: true if root nodes are the same, false otherwise</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="n">nodeOne</span><span class="p">)</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="n">nodeTwo</span><span class="p">)</span>


<span class="n">ds</span> <span class="o">=</span> <span class="n">DisjointSet</span><span class="p">(</span><span class="mi">8</span><span class="p">)</span>
<span class="n">ds</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
<span class="n">ds</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
<span class="n">ds</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
<span class="n">ds</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">)</span>
<span class="n">ds</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">)</span>
<span class="c1"># ds = DisjointSet(10)</span>
<span class="c1"># ds.union(1, 2)</span>
<span class="c1"># ds.union(2, 5)</span>
<span class="c1"># ds.union(5, 6)</span>
<span class="c1"># ds.union(6, 7)</span>
<span class="c1"># ds.union(3, 8)</span>
<span class="c1"># ds.union(8, 9)</span>

<span class="nb">print</span><span class="p">(</span><span class="n">ds</span><span class="o">.</span><span class="n">isConnected</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="n">ds</span><span class="o">.</span><span class="n">isConnected</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="n">ds</span><span class="o">.</span><span class="n">isConnected</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">6</span><span class="p">))</span>

<span class="c1"># print(ds.isConnected(1, 5))</span>
<span class="c1"># print(ds.isConnected(5, 7))</span>
<span class="c1"># print(ds.isConnected(4, 9))</span>
<span class="c1"># ds.union(9, 4)</span>
<span class="c1"># print(ds.isConnected(4, 9))</span>
<span class="c1">#</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Arr[0, 1, 2, 3, 4, 5, 6, 7]
0 1
N1:0, N2:1, Arr:[0, 0, 2, 3, 4, 5, 6, 7]
0 3
N1:0, N2:3, Arr:[0, 0, 2, 0, 4, 5, 6, 7]
0 2
N1:1, N2:2, Arr:[0, 0, 0, 0, 4, 5, 6, 7]
4 5
N1:4, N2:5, Arr:[0, 0, 0, 0, 4, 4, 6, 7]
6 7
N1:6, N2:7, Arr:[0, 0, 0, 0, 4, 4, 6, 6]
True
True
False
</pre></div>
</div>
</div>
</div>
</section>
<section id="disjoint-sets-quick-union">
<h4>Disjoint sets - Quick union<a class="headerlink" href="#disjoint-sets-quick-union" title="Permalink to this headline">#</a></h4>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># %load ./pycharm/graphs/disjoint_set_02_quick_union.py</span>
<span class="k">class</span> <span class="nc">DisjointSet</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    This implementation is of disjoint set - quick union</span>
<span class="sd">    As the worst case complexity of find and union each is O(n), generally it will perform better than n * O(n) &lt;= O(n^2)</span>
<span class="sd">    So the quick union is more efficient than quick find method whose time complexity is n * O(n) = O(n^2)</span>
<span class="sd">    Hint: Instead of storing parent node in the array, store the root node</span>
<span class="sd">    Then we won&#39;t need iteration from the leaf node to the parent root node</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">size</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rootArr</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">size</span><span class="p">)]</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Arr</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">rootArr</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">find</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Time complexity O(n) is the worst case scenario</span>
<span class="sd">        Return the element of the corresponding index</span>
<span class="sd">        :param index: index of the array</span>
<span class="sd">        :return: element</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">while</span> <span class="n">index</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rootArr</span><span class="p">[</span><span class="n">index</span><span class="p">]:</span>
            <span class="n">index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rootArr</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">index</span>

    <span class="k">def</span> <span class="nf">union</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nodeOne</span><span class="p">,</span> <span class="n">nodeTwo</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Time complexity O(n) is the worst case scenario</span>
<span class="sd">        If the elements have a common root, no action is taken.</span>
<span class="sd">        If the elements have different root, the root of node one is assigned to root of node two.</span>
<span class="sd">        :param nodeOne: the first element</span>
<span class="sd">        :param nodeTwo: the second element</span>
<span class="sd">        :return: None</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">rootOne</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="n">nodeOne</span><span class="p">)</span>
        <span class="n">rootTwo</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="n">nodeTwo</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">rootOne</span><span class="p">,</span> <span class="n">rootTwo</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">rootOne</span> <span class="o">!=</span> <span class="n">rootTwo</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">rootArr</span><span class="p">[</span><span class="n">rootTwo</span><span class="p">]</span> <span class="o">=</span> <span class="n">rootOne</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;N1:</span><span class="si">{</span><span class="n">nodeOne</span><span class="si">}</span><span class="s1">, N2:</span><span class="si">{</span><span class="n">nodeTwo</span><span class="si">}</span><span class="s1">, Arr:</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">rootArr</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">isConnected</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nodeOne</span><span class="p">,</span> <span class="n">nodeTwo</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Time complexity O(n)</span>
<span class="sd">        Validates if the root node of element one and element two are same</span>
<span class="sd">        :param nodeOne: node one</span>
<span class="sd">        :param nodeTwo: node two</span>
<span class="sd">        :return: true if root nodes are the same, false otherwise</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="n">nodeOne</span><span class="p">)</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="n">nodeTwo</span><span class="p">)</span>


<span class="n">ds</span> <span class="o">=</span> <span class="n">DisjointSet</span><span class="p">(</span><span class="mi">8</span><span class="p">)</span>
<span class="n">ds</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
<span class="n">ds</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
<span class="n">ds</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
<span class="n">ds</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">)</span>
<span class="n">ds</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">)</span>
<span class="c1"># ds = DisjointSet(10)</span>
<span class="c1"># ds.union(1, 2)</span>
<span class="c1"># ds.union(2, 5)</span>
<span class="c1"># ds.union(5, 6)</span>
<span class="c1"># ds.union(6, 7)</span>
<span class="c1"># ds.union(3, 8)</span>
<span class="c1"># ds.union(8, 9)</span>

<span class="nb">print</span><span class="p">(</span><span class="n">ds</span><span class="o">.</span><span class="n">isConnected</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="n">ds</span><span class="o">.</span><span class="n">isConnected</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="n">ds</span><span class="o">.</span><span class="n">isConnected</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">6</span><span class="p">))</span>

<span class="c1"># print(ds.isConnected(1, 5))</span>
<span class="c1"># print(ds.isConnected(5, 7))</span>
<span class="c1"># print(ds.isConnected(4, 9))</span>
<span class="c1"># ds.union(9, 4)</span>
<span class="c1"># print(ds.isConnected(4, 9))</span>
<span class="c1">#</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Arr[0, 1, 2, 3, 4, 5, 6, 7]
0 1
N1:0, N2:1, Arr:[0, 0, 2, 3, 4, 5, 6, 7]
0 3
N1:0, N2:3, Arr:[0, 0, 2, 0, 4, 5, 6, 7]
0 2
N1:1, N2:2, Arr:[0, 0, 0, 0, 4, 5, 6, 7]
4 5
N1:4, N2:5, Arr:[0, 0, 0, 0, 4, 4, 6, 7]
6 7
N1:6, N2:7, Arr:[0, 0, 0, 0, 4, 4, 6, 6]
True
True
False
</pre></div>
</div>
</div>
</div>
</section>
<section id="disjoint-sets-union-by-rank">
<h4>Disjoint sets - Union by rank<a class="headerlink" href="#disjoint-sets-union-by-rank" title="Permalink to this headline">#</a></h4>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># %load ./pycharm/graphs/disjoint_set_03_union_by_rank.py</span>
<span class="k">class</span> <span class="nc">DisjointSet</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    This implementation is of disjoint set - quick union</span>
<span class="sd">    Additionally maintain the rank/height of each vertex from the root</span>
<span class="sd">    As the worst case complexity of find and union each is O(n), generally it will perform better than n * O(n) &lt;= O(n^2)</span>
<span class="sd">    So the quick union is more efficient than quick find method whose time complexity is n * O(n) = O(n^2)</span>
<span class="sd">    Hint: Instead of storing parent node in the array, store the root node</span>
<span class="sd">    Then we won&#39;t need iteration from the leaf node to the parent root node</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">size</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rootArr</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">size</span><span class="p">)]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rankArr</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">size</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Arr</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">rootArr</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Height</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">rankArr</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">find</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Time complexity O(n) is the worst case scenario</span>
<span class="sd">        Return the element of the corresponding index</span>
<span class="sd">        :param index: index of the array</span>
<span class="sd">        :return: element</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">while</span> <span class="n">index</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rootArr</span><span class="p">[</span><span class="n">index</span><span class="p">]:</span>
            <span class="n">index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rootArr</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">index</span>

    <span class="k">def</span> <span class="nf">union</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nodeOne</span><span class="p">,</span> <span class="n">nodeTwo</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Time complexity O(n) is the worst case scenario</span>
<span class="sd">        If the elements have a common root, no action is taken.</span>
<span class="sd">        If the elements have different root, the root of node one is assigned to root of node two.</span>
<span class="sd">        :param nodeOne: the first element</span>
<span class="sd">        :param nodeTwo: the second element</span>
<span class="sd">        :return: None</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">rootOne</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="n">nodeOne</span><span class="p">)</span>
        <span class="n">rootTwo</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="n">nodeTwo</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">rootOne</span><span class="p">,</span> <span class="n">rootTwo</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">rootOne</span> <span class="o">!=</span> <span class="n">rootTwo</span><span class="p">):</span>
            <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rankArr</span><span class="p">[</span><span class="n">rootOne</span><span class="p">]</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">rankArr</span><span class="p">[</span><span class="n">rootTwo</span><span class="p">]):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">rootArr</span><span class="p">[</span><span class="n">rootTwo</span><span class="p">]</span> <span class="o">=</span> <span class="n">rootOne</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">rankArr</span><span class="p">[</span><span class="n">rootTwo</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rankArr</span><span class="p">[</span><span class="n">rootOne</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="k">elif</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rankArr</span><span class="p">[</span><span class="n">rootOne</span><span class="p">]</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">rankArr</span><span class="p">[</span><span class="n">rootTwo</span><span class="p">]):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">rootArr</span><span class="p">[</span><span class="n">rootOne</span><span class="p">]</span> <span class="o">=</span> <span class="n">rootTwo</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">rankArr</span><span class="p">[</span><span class="n">rootOne</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rankArr</span><span class="p">[</span><span class="n">rootTwo</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">rootArr</span><span class="p">[</span><span class="n">rootTwo</span><span class="p">]</span> <span class="o">=</span> <span class="n">rootOne</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">rankArr</span><span class="p">[</span><span class="n">rootOne</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;N1:</span><span class="si">{</span><span class="n">nodeOne</span><span class="si">}</span><span class="s1">, N2:</span><span class="si">{</span><span class="n">nodeTwo</span><span class="si">}</span><span class="s1">, Arr:</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">rootArr</span><span class="si">}</span><span class="s1">, Height:</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">rankArr</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">isConnected</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nodeOne</span><span class="p">,</span> <span class="n">nodeTwo</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Time complexity O(n)</span>
<span class="sd">        Validates if the root node of element one and element two are same</span>
<span class="sd">        :param nodeOne: node one</span>
<span class="sd">        :param nodeTwo: node two</span>
<span class="sd">        :return: true if root nodes are the same, false otherwise</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">val</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="n">nodeOne</span><span class="p">)</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="n">nodeTwo</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;N1:</span><span class="si">{</span><span class="n">nodeOne</span><span class="si">}</span><span class="s1">, N2:</span><span class="si">{</span><span class="n">nodeTwo</span><span class="si">}</span><span class="s1">, IsConnected:</span><span class="si">{</span><span class="n">val</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">val</span>


<span class="c1"># ds = DisjointSet(8)</span>
<span class="c1"># ds.union(0,1)</span>
<span class="c1"># ds.union(0,3)</span>
<span class="c1"># ds.union(1,2)</span>
<span class="c1"># ds.union(4,5)</span>
<span class="c1"># ds.union(6,7)</span>
<span class="n">ds</span> <span class="o">=</span> <span class="n">DisjointSet</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
<span class="n">ds</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="n">ds</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
<span class="n">ds</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">)</span>
<span class="n">ds</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">)</span>
<span class="n">ds</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">8</span><span class="p">)</span>
<span class="n">ds</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="mi">9</span><span class="p">)</span>

<span class="c1"># ds.isConnected(2,3)</span>
<span class="c1"># ds.isConnected(2,3)</span>
<span class="c1"># ds.isConnected(2,6)</span>

<span class="n">ds</span><span class="o">.</span><span class="n">isConnected</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
<span class="n">ds</span><span class="o">.</span><span class="n">isConnected</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">7</span><span class="p">)</span>
<span class="n">ds</span><span class="o">.</span><span class="n">isConnected</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">9</span><span class="p">)</span>
<span class="n">ds</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="mi">9</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="n">ds</span><span class="o">.</span><span class="n">isConnected</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">9</span><span class="p">)</span>
<span class="c1">#</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Arr[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
Height[1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
1 2
N1:1, N2:2, Arr:[0, 1, 1, 3, 4, 5, 6, 7, 8, 9], Height:[1, 2, 1, 1, 1, 1, 1, 1, 1, 1]
1 5
N1:2, N2:5, Arr:[0, 1, 1, 3, 4, 1, 6, 7, 8, 9], Height:[1, 2, 1, 1, 1, 3, 1, 1, 1, 1]
1 6
N1:5, N2:6, Arr:[0, 1, 1, 3, 4, 1, 1, 7, 8, 9], Height:[1, 2, 1, 1, 1, 3, 3, 1, 1, 1]
1 7
N1:6, N2:7, Arr:[0, 1, 1, 3, 4, 1, 1, 1, 8, 9], Height:[1, 2, 1, 1, 1, 3, 3, 3, 1, 1]
3 8
N1:3, N2:8, Arr:[0, 1, 1, 3, 4, 1, 1, 1, 3, 9], Height:[1, 2, 1, 2, 1, 3, 3, 3, 1, 1]
3 9
N1:8, N2:9, Arr:[0, 1, 1, 3, 4, 1, 1, 1, 3, 3], Height:[1, 2, 1, 2, 1, 3, 3, 3, 1, 3]
N1:1, N2:5, IsConnected:True
N1:5, N2:7, IsConnected:True
N1:4, N2:9, IsConnected:False
3 4
N1:9, N2:4, Arr:[0, 1, 1, 3, 3, 1, 1, 1, 3, 3], Height:[1, 2, 1, 2, 3, 3, 3, 3, 1, 3]
N1:4, N2:9, IsConnected:True
</pre></div>
</div>
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>True
</pre></div>
</div>
</div>
</div>
</section>
<section id="disjoint-sets-path-compression-optimization">
<h4>Disjoint Sets - Path Compression Optimization<a class="headerlink" href="#disjoint-sets-path-compression-optimization" title="Permalink to this headline">#</a></h4>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># %load ./pycharm/graphs/disjoint_set_04_path_compression.py</span>
<span class="k">class</span> <span class="nc">DisjointSet</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    This implementation is of disjoint set is an optimization method called path compression for find() method</span>
<span class="sd">    Here the leaf and child nodes are directly connected to the root vertex node</span>
<span class="sd">    The path compression is implemented in find() method using recursion</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">size</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rootArr</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">size</span><span class="p">)]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rankArr</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">size</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Arr</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">rootArr</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Height</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">rankArr</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">find</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Time complexity O(n) is the worst case scenario</span>
<span class="sd">        Return the element of the corresponding index</span>
<span class="sd">        :param index: index of the array</span>
<span class="sd">        :return: element</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="n">index</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">rootArr</span><span class="p">[</span><span class="n">index</span><span class="p">]:</span>
            <span class="k">return</span> <span class="n">index</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rootArr</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rootArr</span><span class="p">[</span><span class="n">index</span><span class="p">])</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">rootArr</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>


    <span class="k">def</span> <span class="nf">union</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nodeOne</span><span class="p">,</span> <span class="n">nodeTwo</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Time complexity O(n) is the worst case scenario</span>
<span class="sd">        If the elements have a common root, no action is taken.</span>
<span class="sd">        If the elements have different root, the root of node one is assigned to root of node two.</span>
<span class="sd">        :param nodeOne: the first element</span>
<span class="sd">        :param nodeTwo: the second element</span>
<span class="sd">        :return: None</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">rootOne</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="n">nodeOne</span><span class="p">)</span>
        <span class="n">rootTwo</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="n">nodeTwo</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">rootOne</span><span class="p">,</span> <span class="n">rootTwo</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">rootOne</span> <span class="o">!=</span> <span class="n">rootTwo</span><span class="p">):</span>
            <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rankArr</span><span class="p">[</span><span class="n">rootOne</span><span class="p">]</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">rankArr</span><span class="p">[</span><span class="n">rootTwo</span><span class="p">]):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">rootArr</span><span class="p">[</span><span class="n">rootTwo</span><span class="p">]</span> <span class="o">=</span> <span class="n">rootOne</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">rankArr</span><span class="p">[</span><span class="n">rootTwo</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rankArr</span><span class="p">[</span><span class="n">rootOne</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="k">elif</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rankArr</span><span class="p">[</span><span class="n">rootOne</span><span class="p">]</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">rankArr</span><span class="p">[</span><span class="n">rootTwo</span><span class="p">]):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">rootArr</span><span class="p">[</span><span class="n">rootOne</span><span class="p">]</span> <span class="o">=</span> <span class="n">rootTwo</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">rankArr</span><span class="p">[</span><span class="n">rootOne</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rankArr</span><span class="p">[</span><span class="n">rootTwo</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">rootArr</span><span class="p">[</span><span class="n">rootTwo</span><span class="p">]</span> <span class="o">=</span> <span class="n">rootOne</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">rankArr</span><span class="p">[</span><span class="n">rootOne</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;N1:</span><span class="si">{</span><span class="n">nodeOne</span><span class="si">}</span><span class="s1">, N2:</span><span class="si">{</span><span class="n">nodeTwo</span><span class="si">}</span><span class="s1">, Arr:</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">rootArr</span><span class="si">}</span><span class="s1">, Height:</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">rankArr</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">isConnected</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nodeOne</span><span class="p">,</span> <span class="n">nodeTwo</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Time complexity O(n)</span>
<span class="sd">        Validates if the root node of element one and element two are same</span>
<span class="sd">        :param nodeOne: node one</span>
<span class="sd">        :param nodeTwo: node two</span>
<span class="sd">        :return: true if root nodes are the same, false otherwise</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">val</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="n">nodeOne</span><span class="p">)</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="n">nodeTwo</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;N1:</span><span class="si">{</span><span class="n">nodeOne</span><span class="si">}</span><span class="s1">, N2:</span><span class="si">{</span><span class="n">nodeTwo</span><span class="si">}</span><span class="s1">, IsConnected:</span><span class="si">{</span><span class="n">val</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">val</span>


<span class="c1"># ds = DisjointSet(8)</span>
<span class="c1"># ds.union(0,1)</span>
<span class="c1"># ds.union(0,3)</span>
<span class="c1"># ds.union(1,2)</span>
<span class="c1"># ds.union(4,5)</span>
<span class="c1"># ds.union(6,7)</span>
<span class="n">ds</span> <span class="o">=</span> <span class="n">DisjointSet</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
<span class="n">ds</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="n">ds</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
<span class="n">ds</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">)</span>
<span class="n">ds</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">)</span>
<span class="n">ds</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">8</span><span class="p">)</span>
<span class="n">ds</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="mi">9</span><span class="p">)</span>

<span class="c1"># ds.isConnected(2,3)</span>
<span class="c1"># ds.isConnected(2,3)</span>
<span class="c1"># ds.isConnected(2,6)</span>

<span class="n">ds</span><span class="o">.</span><span class="n">isConnected</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
<span class="n">ds</span><span class="o">.</span><span class="n">isConnected</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">7</span><span class="p">)</span>
<span class="n">ds</span><span class="o">.</span><span class="n">isConnected</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">9</span><span class="p">)</span>
<span class="n">ds</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="mi">9</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="n">ds</span><span class="o">.</span><span class="n">isConnected</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">9</span><span class="p">)</span>
<span class="c1">#</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Arr[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
Height[1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
1 2
N1:1, N2:2, Arr:[0, 1, 1, 3, 4, 5, 6, 7, 8, 9], Height:[1, 2, 1, 1, 1, 1, 1, 1, 1, 1]
1 5
N1:2, N2:5, Arr:[0, 1, 1, 3, 4, 1, 6, 7, 8, 9], Height:[1, 2, 1, 1, 1, 3, 1, 1, 1, 1]
1 
</pre></div>
</div>
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>6
N1:5, N2:6, Arr:[0, 1, 1, 3, 4, 1, 1, 7, 8, 9], Height:[1, 2, 1, 1, 1, 3, 3, 1, 1, 1]
1 7
N1:6, N2:7, Arr:[0, 1, 1, 3, 4, 1, 1, 1, 8, 9], Height:[1, 2, 1, 1, 1, 3, 3, 3, 1, 1]
3 8
N1:3, N2:8, Arr:[0, 1, 1, 3, 4, 1, 1, 1, 3, 9], Height:[1, 2, 1, 2, 1, 3, 3, 3, 1, 1]
3 9
N1:8, N2:9, Arr:[0, 1, 1, 3, 4, 1, 1, 1, 3, 3], Height:[1, 2, 1, 2, 1, 3, 3, 3, 1, 3]
N1:1, N2:5, IsConnected:True
N1:5, N2:7, IsConnected:True
N1:4, N2:9, IsConnected:False
3 4
N1:9, N2:4, Arr:[0, 1, 1, 3, 3, 1, 1, 1, 3, 3], Height:[1, 2, 1, 2, 3, 3, 3, 3, 1, 3]
N1:4, N2:9, IsConnected:True
</pre></div>
</div>
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>True
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># %load ./pycharm/graphs/disjoint_set_05P_no_of_province.py</span>
<span class="k">class</span> <span class="nc">DisjointSet</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    This implementation is of disjoint set is an optimization method called path compression for find() method</span>
<span class="sd">    Here the leaf and child nodes are directly connected to the root vertex node</span>
<span class="sd">    The path compression is implemented in find() method using recursion</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">size</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rootArr</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">size</span><span class="p">)]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rankArr</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">size</span>
        <span class="c1"># Initially set to number of nodes, during union it is reduced by 1 as each edge means one less province</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">count</span> <span class="o">=</span> <span class="n">size</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Arr</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">rootArr</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Height</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">rankArr</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">find</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Time complexity O(n) is the worst case scenario</span>
<span class="sd">        Return the element of the corresponding index</span>
<span class="sd">        :param index: index of the array</span>
<span class="sd">        :return: element</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="n">index</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">rootArr</span><span class="p">[</span><span class="n">index</span><span class="p">]:</span>
            <span class="k">return</span> <span class="n">index</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rootArr</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rootArr</span><span class="p">[</span><span class="n">index</span><span class="p">])</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">rootArr</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>


    <span class="k">def</span> <span class="nf">union</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nodeOne</span><span class="p">,</span> <span class="n">nodeTwo</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Time complexity O(n) is the worst case scenario</span>
<span class="sd">        If the elements have a common root, no action is taken.</span>
<span class="sd">        If the elements have different root, the root of node one is assigned to root of node two.</span>
<span class="sd">        :param nodeOne: the first element</span>
<span class="sd">        :param nodeTwo: the second element</span>
<span class="sd">        :return: None</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">rootOne</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="n">nodeOne</span><span class="p">)</span>
        <span class="n">rootTwo</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="n">nodeTwo</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">rootOne</span><span class="p">,</span> <span class="n">rootTwo</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">rootOne</span> <span class="o">!=</span> <span class="n">rootTwo</span><span class="p">):</span>
            <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rankArr</span><span class="p">[</span><span class="n">rootOne</span><span class="p">]</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">rankArr</span><span class="p">[</span><span class="n">rootTwo</span><span class="p">]):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">rootArr</span><span class="p">[</span><span class="n">rootTwo</span><span class="p">]</span> <span class="o">=</span> <span class="n">rootOne</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">rankArr</span><span class="p">[</span><span class="n">rootTwo</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rankArr</span><span class="p">[</span><span class="n">rootOne</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="k">elif</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rankArr</span><span class="p">[</span><span class="n">rootOne</span><span class="p">]</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">rankArr</span><span class="p">[</span><span class="n">rootTwo</span><span class="p">]):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">rootArr</span><span class="p">[</span><span class="n">rootOne</span><span class="p">]</span> <span class="o">=</span> <span class="n">rootTwo</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">rankArr</span><span class="p">[</span><span class="n">rootOne</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rankArr</span><span class="p">[</span><span class="n">rootTwo</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">rootArr</span><span class="p">[</span><span class="n">rootTwo</span><span class="p">]</span> <span class="o">=</span> <span class="n">rootOne</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">rankArr</span><span class="p">[</span><span class="n">rootOne</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">count</span> <span class="o">-=</span> <span class="mi">1</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;N1:</span><span class="si">{</span><span class="n">nodeOne</span><span class="si">}</span><span class="s1">, N2:</span><span class="si">{</span><span class="n">nodeTwo</span><span class="si">}</span><span class="s1">, Arr:</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">rootArr</span><span class="si">}</span><span class="s1">, Height:</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">rankArr</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">isConnected</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nodeOne</span><span class="p">,</span> <span class="n">nodeTwo</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Time complexity O(n)</span>
<span class="sd">        Validates if the root node of element one and element two are same</span>
<span class="sd">        :param nodeOne: node one</span>
<span class="sd">        :param nodeTwo: node two</span>
<span class="sd">        :return: true if root nodes are the same, false otherwise</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">val</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="n">nodeOne</span><span class="p">)</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="n">nodeTwo</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;N1:</span><span class="si">{</span><span class="n">nodeOne</span><span class="si">}</span><span class="s1">, N2:</span><span class="si">{</span><span class="n">nodeTwo</span><span class="si">}</span><span class="s1">, IsConnected:</span><span class="si">{</span><span class="n">val</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">val</span>

    <span class="k">def</span> <span class="nf">getCount</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Returns the number of provinces</span>
<span class="sd">        :return: count</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">count</span>

<span class="k">class</span> <span class="nc">NoOfProvince</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    TODO</span>
<span class="sd">    There are n cities. Some of them are connected, while some are not. If city a is connected directly</span>
<span class="sd">    with city b, and city b is connected directly with city c, then city a is connected indirectly with city c.</span>

<span class="sd">    A province is a group of directly or indirectly connected cities and no other cities outside of the group.</span>

<span class="sd">    You are given an n x n matrix isConnected where isConnected[i][j] = 1 if the ith city and the jth city are</span>
<span class="sd">    directly connected, and isConnected[i][j] = 0 otherwise.</span>

<span class="sd">    Return the total number of provinces.</span>

<span class="sd">    Input: isConnected = [[1,1,0],[1,1,0],[0,0,1]]</span>
<span class="sd">    Output: 2</span>

<span class="sd">    Input: isConnected = [[1,0,0],[0,1,0],[0,0,1]]</span>
<span class="sd">    Output: 3</span>

<span class="sd">    Constraints:</span>
<span class="sd">        1 &lt;= n &lt;= 200</span>
<span class="sd">        n == isConnected.length</span>
<span class="sd">        n == isConnected[i].length</span>
<span class="sd">        isConnected[i][j] is 1 or 0.</span>
<span class="sd">        isConnected[i][i] == 1</span>
<span class="sd">        isConnected[i][j] == isConnected[j][i]</span>
<span class="sd">    &#39;&#39;&#39;</span>

    <span class="k">def</span> <span class="nf">findCircleNum</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">isConnected</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Input: isConnected = [[1,1,0],[1,1,0],[0,0,1]]</span>
<span class="sd">        Output: 2</span>

<span class="sd">        Input: isConnected = [[1,0,0],[0,1,0],[0,0,1]]</span>
<span class="sd">        Output: 3</span>

<span class="sd">        :type isConnected: List[List[int]]</span>
<span class="sd">        :rtype: int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">size</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">isConnected</span><span class="p">)</span>
        <span class="n">ds</span> <span class="o">=</span> <span class="n">DisjointSet</span><span class="p">(</span><span class="n">size</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">size</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">row</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span> <span class="c1"># Just loop over upper diagonal matrix, no need to loop over diagonal elements</span>
                <span class="k">if</span> <span class="n">isConnected</span><span class="p">[</span><span class="n">row</span><span class="p">][</span><span class="n">col</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">ds</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ds</span><span class="o">.</span><span class="n">getCount</span><span class="p">()</span>


<span class="c1"># isConnected = [[1, 1, 0], [1, 1, 0], [0, 0, 1]]</span>
<span class="n">isConnected</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]]</span>
<span class="n">ds</span> <span class="o">=</span> <span class="n">NoOfProvince</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="n">ds</span><span class="o">.</span><span class="n">findCircleNum</span><span class="p">(</span><span class="n">isConnected</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Arr[0, 1, 2]
Height[1, 1, 1]
0 0
N1:0, N2:0, Arr:[0, 1, 2], Height:[1, 1, 1]
1 1
N1:1, N2:1, Arr:[0, 1, 2], Height:[1, 1, 1]
2 2
N1:2, N2:2, Arr:[0, 1, 2], Height:[1, 1, 1]
3
</pre></div>
</div>
</div>
</div>
</section>
<section id="valid-graph-tree">
<h4>Valid Graph Tree<a class="headerlink" href="#valid-graph-tree" title="Permalink to this headline">#</a></h4>
<p>G is a tree iff:</p>
<ul class="simple">
<li><p>G is fully connected, that is, for every pair of nodes in G, there is a path between them</p></li>
<li><p>G contains no cycles, that is, there is exactly onne path between each pair of nodes</p></li>
</ul>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># %load ./pycharm/graphs/valid_graph_tree2.py</span>
<span class="k">class</span> <span class="nc">Solution</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">validTree</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">edges</span><span class="p">):</span>
        <span class="c1"># Check if number of edges is one less than number of nodes</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">edges</span><span class="p">)</span> <span class="o">!=</span> <span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>

        <span class="c1"># Initialize and assign node neighbors in its corresponding index to create adjacency list</span>
        <span class="c1"># adjList = [[]] * n</span>
        <span class="n">adjList</span> <span class="o">=</span> <span class="p">[[]</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">)]</span>
        <span class="k">for</span> <span class="n">l</span><span class="p">,</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">edges</span><span class="p">:</span>
            <span class="n">adjList</span><span class="p">[</span><span class="n">l</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>
            <span class="n">adjList</span><span class="p">[</span><span class="n">r</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">l</span><span class="p">)</span>

        <span class="c1"># Create parent dictionary which holds parent node information. The first node is assigned -1 parent node</span>
        <span class="n">parentDict</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">:</span> <span class="o">-</span><span class="mi">1</span><span class="p">}</span>

        <span class="c1"># Create stack of adjacent neighbors</span>
        <span class="n">stack</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="c1"># loop over all nodes adjacent neighbors starting with node 0 till all nodes are visited</span>
        <span class="k">while</span><span class="p">(</span><span class="n">stack</span><span class="p">):</span>
            <span class="n">node</span> <span class="o">=</span> <span class="n">stack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
            <span class="c1"># Loop over all adjacent neighbor to corresponding stacked off node</span>
            <span class="k">for</span> <span class="n">neighbor</span> <span class="ow">in</span> <span class="n">adjList</span><span class="p">[</span><span class="n">node</span><span class="p">]:</span>
                <span class="c1"># Ignore the trivial cycles for example A-B-A of undirected graph</span>
                <span class="k">if</span> <span class="n">neighbor</span> <span class="o">==</span> <span class="n">parentDict</span><span class="p">[</span><span class="n">node</span><span class="p">]:</span>
                    <span class="k">continue</span>
                <span class="c1"># If neighbor is already listed down in parent dictionary key, means there is a cycle in graph</span>
                <span class="k">if</span> <span class="n">neighbor</span> <span class="ow">in</span> <span class="n">parentDict</span><span class="p">:</span>
                    <span class="k">return</span> <span class="kc">False</span>
                <span class="c1"># Append neighbor in the stack having observed them</span>
                <span class="n">stack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">neighbor</span><span class="p">)</span>
                <span class="n">parentDict</span><span class="p">[</span><span class="n">neighbor</span><span class="p">]</span> <span class="o">=</span> <span class="n">node</span>
        <span class="c1"># Return if valid graph will have the same number of nodes</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="n">parentDict</span><span class="p">)</span> <span class="o">==</span> <span class="n">n</span>

<span class="n">s</span> <span class="o">=</span> <span class="n">Solution</span><span class="p">()</span>
<span class="n">nodes</span> <span class="o">=</span> <span class="mi">5</span>
<span class="n">edges</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="mi">3</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">]]</span>
<span class="n">nodes</span> <span class="o">=</span> <span class="mi">5</span>
<span class="n">edges</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="mi">3</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">]]</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;nodes=</span><span class="si">{</span><span class="n">nodes</span><span class="si">}</span><span class="s1">, edges=</span><span class="si">{</span><span class="n">edges</span><span class="si">}</span><span class="s1">, isValidTree=</span><span class="si">{</span><span class="n">s</span><span class="o">.</span><span class="n">validTree</span><span class="p">(</span><span class="n">nodes</span><span class="p">,</span> <span class="n">edges</span><span class="p">)</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
<span class="n">nodes</span> <span class="o">=</span> <span class="mi">8</span>
<span class="n">edges</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span> <span class="p">[</span><span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">]]</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;nodes=</span><span class="si">{</span><span class="n">nodes</span><span class="si">}</span><span class="s1">, edges=</span><span class="si">{</span><span class="n">edges</span><span class="si">}</span><span class="s1">, isValidTree=</span><span class="si">{</span><span class="n">s</span><span class="o">.</span><span class="n">validTree</span><span class="p">(</span><span class="n">nodes</span><span class="p">,</span> <span class="n">edges</span><span class="p">)</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
<span class="c1"># nodes = 8</span>
<span class="c1"># edges = [[0, 1], [0, 3], [1, 2], [4, 5], [6, 7]]</span>
<span class="c1"># nodes = 1</span>
<span class="c1"># edges = []</span>
<span class="c1"># nodes = 2</span>
<span class="c1"># edges = []</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>nodes=5, edges=[[0, 1], [0, 2], [0, 3], [1, 4]], isValidTree=True
nodes=8, edges=[[0, 1], [0, 3], [1, 2], [4, 5], [6, 7]], isValidTree=False
</pre></div>
</div>
</div>
</div>
</section>
<section id="dfs-depth-first-search">
<h4>DFS - Depth-first search<a class="headerlink" href="#dfs-depth-first-search" title="Permalink to this headline">#</a></h4>
<ul class="simple">
<li><p>Given a graph, how can we find all of its vertices, and how can we find all paths between two vertices?</p></li>
<li><p>DFS is generally used to:</p>
<ul>
<li><p><strong>traverse all vertices</strong></p></li>
<li><p><strong>traverse all paths between any two vertices</strong></p></li>
</ul>
</li>
<li><p><strong>adjacency list</strong> can be used to look up for the adjacent neighbors of a given node</p>
<ul>
<li><p>best for cases where number of nodes is more than number of edges</p></li>
</ul>
</li>
<li><p>linked list would not be a good choice here</p></li>
<li><p><strong>search till we reach to the depth of graph</strong></p></li>
<li><p>uses <strong>stack</strong> to solve - <strong>LIFO</strong></p>
<ul>
<li><p>to go to the previous state, simply remove the current state and we will reach onto the previous state</p></li>
<li><p>uses recursion to solve</p></li>
</ul>
</li>
<li><p>Algo - traversing all vertices</p>
<ul>
<li><p>choose a node</p></li>
<li><p>put in stack</p></li>
<li><p>mark it as visited</p></li>
<li><p>pop from stack</p></li>
<li><p>check all the neighboring nodes</p></li>
<li><p>put in stack</p></li>
<li><p>and loop deeper and deeper before checking for the remaining neigboring nodes</p></li>
<li><p>if all nodes are visited go back to the previous</p></li>
</ul>
</li>
</ul>
<section id="dfs-iterative-depth-first-search">
<h5>DFS - Iterative depth-first search<a class="headerlink" href="#dfs-iterative-depth-first-search" title="Permalink to this headline">#</a></h5>
<ul class="simple">
<li><p>Undirected graph</p>
<ul>
<li><p>Undirected graph contains trivial cycle as A - B - A, if there is an undirected edge between node A and node B</p></li>
<li><p>So in undirected graph, detecting cycles should exclude trivial cycles</p>
<ul>
<li><p>Delete the opp direction edge, that is when you follow A-B, delete the opp edge B-A</p></li>
</ul>
</li>
</ul>
</li>
</ul>
</section>
</section>
<section id="dfs-find-if-path-exists-in-graph">
<h4>DFS - Find if path exists in graph<a class="headerlink" href="#dfs-find-if-path-exists-in-graph" title="Permalink to this headline">#</a></h4>
<p align="center"><img src="images/pathExists.png" width=400 height=400> </p> <div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># %load ./pycharm/graphs/path_exists.py</span>
<span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">validPath</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">edges</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Validate if the connection between two nodes exist</span>
<span class="sd">        :param n: number of nodes in graph</span>
<span class="sd">        :param edges: connections in the graph</span>
<span class="sd">        :param start: start node</span>
<span class="sd">        :param end: end node</span>
<span class="sd">        :return: True if there is a valid path between the nodes otherwise False</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="c1"># Create and initialize the adjacency list</span>
        <span class="n">adjPath</span> <span class="o">=</span> <span class="p">[[]</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">)]</span>
        <span class="k">for</span> <span class="n">l</span><span class="p">,</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">edges</span><span class="p">:</span>
            <span class="n">adjPath</span><span class="p">[</span><span class="n">l</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>
            <span class="n">adjPath</span><span class="p">[</span><span class="n">r</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">l</span><span class="p">)</span>
        <span class="c1"># Create a set to keep track of visited nodes</span>
        <span class="n">seenSet</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="c1"># Initialize stack to start with start node</span>
        <span class="n">stack</span> <span class="o">=</span> <span class="p">[</span><span class="n">start</span><span class="p">]</span>
        <span class="c1"># Loop over the stack</span>
        <span class="k">while</span><span class="p">(</span><span class="n">stack</span><span class="p">):</span>
            <span class="c1"># Pop current node from the stack</span>
            <span class="n">node</span> <span class="o">=</span> <span class="n">stack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
            <span class="c1"># Check if the node is the end node</span>
            <span class="k">if</span> <span class="n">node</span> <span class="o">==</span> <span class="n">end</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">True</span>
            <span class="c1"># Validate if node is already visited</span>
            <span class="k">if</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">seenSet</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="c1"># If end node not seen, add it into the set</span>
            <span class="n">seenSet</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
            <span class="c1"># Add neighbors into the stack</span>
            <span class="n">stack</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">adjPath</span><span class="p">[</span><span class="n">node</span><span class="p">])</span>
        <span class="c1"># The stack is empty and the end node is not connected</span>
        <span class="k">return</span> <span class="kc">False</span>

<span class="c1"># nodes = 5</span>
<span class="c1"># edges = [[0,1],[0,2],[0,3],[1,4]]</span>
<span class="c1"># start, end = 2, 3</span>
<span class="n">nodes</span> <span class="o">=</span> <span class="mi">8</span>
<span class="n">edges</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span> <span class="p">[</span><span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">]]</span>
<span class="n">start</span><span class="p">,</span> <span class="n">end</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">7</span>

<span class="n">s</span> <span class="o">=</span> <span class="n">Solution</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">validPath</span><span class="p">(</span><span class="n">nodes</span><span class="p">,</span> <span class="n">edges</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>False
</pre></div>
</div>
</div>
</div>
</section>
<section id="dfs-possible-paths-in-dag">
<h4>DFS - Possible paths in DAG<a class="headerlink" href="#dfs-possible-paths-in-dag" title="Permalink to this headline">#</a></h4>
<p align="center"><img src="images/possibleDAGpathUsingDFS.png" width=400 height=400> </p> <div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># %load ./pycharm/graphs/possible_dag_path_using_dfs.py</span>
<span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">allPaths</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">graph</span><span class="p">):</span>
        <span class="k">def</span> <span class="nf">dfs</span><span class="p">(</span><span class="n">node</span><span class="p">):</span>
            <span class="n">path</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
            <span class="c1"># find all possible neighboring nodes to a node</span>
            <span class="n">nextNodes</span> <span class="o">=</span> <span class="n">graph</span><span class="p">[</span><span class="n">node</span><span class="p">]</span>
            <span class="c1"># Check if the current node is the last node of graph, then loop out</span>
            <span class="k">if</span> <span class="n">node</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">graph</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
                <span class="c1"># Copy corresponding path into the main paths container</span>
                <span class="n">paths</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">path</span><span class="o">.</span><span class="n">copy</span><span class="p">())</span>
                <span class="k">return</span>

            <span class="c1"># loop over all the neighboring nodes and find dfs of it</span>
            <span class="k">for</span> <span class="n">nextNode</span> <span class="ow">in</span> <span class="n">nextNodes</span><span class="p">:</span>
                <span class="n">dfs</span><span class="p">(</span><span class="n">nextNode</span><span class="p">)</span>
                <span class="c1"># pop out the last element of connection</span>
                <span class="n">path</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>

        <span class="n">paths</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">path</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">graph</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">graph</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">paths</span>
        <span class="n">dfs</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">paths</span>


<span class="n">graph</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="p">[]]</span>  <span class="c1"># adjacency list</span>
<span class="n">s</span> <span class="o">=</span> <span class="n">Solution</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">allPaths</span><span class="p">(</span><span class="n">graph</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>[[0, 1, 3], [0, 2, 3]]
</pre></div>
</div>
</div>
</div>
</section>
<section id="bfs-breadth-first-search">
<h4>BFS - Breadth-first search<a class="headerlink" href="#bfs-breadth-first-search" title="Permalink to this headline">#</a></h4>
<ul class="simple">
<li><p>search layer by layer instead of going in depth</p></li>
</ul>
<p align="center"><img src="images/bfs_shortestPath.png" width=400 height=400></p>  </section>
</section>
<section id="dp">
<h3>DP<a class="headerlink" href="#dp" title="Permalink to this headline">#</a></h3>
<ul class="simple">
<li><p>the problem asks for optimal(max or min) value or the number of ways of doing something</p></li>
<li><p>future decisions depend on earlier decisions</p></li>
<li><p>Tabulation - Bottom-up</p></li>
<li><p>Recursion and Memoization - Top-down</p></li>
</ul>
<section id="longest-common-subsequence">
<h4>Longest Common Subsequence<a class="headerlink" href="#longest-common-subsequence" title="Permalink to this headline">#</a></h4>
<ul class="simple">
<li><p>String1: <strong>abc</strong>da<strong>f</strong></p></li>
<li><p>String2: <strong>a</strong>c<strong>bcf</strong></p></li>
</ul>
<p align="center"><img src="images/lcs.png" width=400 height=400></p> <div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># %load ./pycharm/arrays/longest_common_subsequence.py</span>
<span class="kn">from</span> <span class="nn">pprint</span> <span class="kn">import</span> <span class="n">pprint</span>


<span class="k">def</span> <span class="nf">findLCSMethod</span><span class="p">(</span><span class="n">str1</span><span class="p">,</span> <span class="n">str2</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Input: two string</span>
<span class="sd">    Method:</span>
<span class="sd">        1. transform string to array of char</span>
<span class="sd">        2. loop over str1 and str2 in nested manner</span>
<span class="sd">        3. if character in nested loop do not match</span>
<span class="sd">           - assign the value max value of (among top and left character)</span>
<span class="sd">           - to handle first row and column - 1, use an additional row and col on top and left</span>
<span class="sd">             - make matrix of +1 size, rowwise and colwise</span>
<span class="sd">           else</span>
<span class="sd">           - assign increment value of top left character</span>
<span class="sd">           - assign character into list for final return</span>
<span class="sd">           - to handle first row and column - 1, use an additional row and col on top and left</span>
<span class="sd">             - make matrix of +1 size, rowwise and colwise</span>
<span class="sd">        4. right bottom element contains the number of common character</span>
<span class="sd">        5. loop from bottom right to top left, finding the common character by using generated matrix</span>
<span class="sd">    Output: longest common string</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">retValue</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">strMatrix</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">str1</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)]</span> <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">str2</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)]</span>
    <span class="n">l1</span><span class="p">,</span> <span class="n">l2</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;&#39;</span><span class="p">],</span> <span class="p">[</span><span class="s1">&#39;&#39;</span><span class="p">]</span>
    <span class="n">l1</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">str2</span><span class="p">))</span>  <span class="c1"># this is important</span>
    <span class="n">l2</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">str1</span><span class="p">))</span>  <span class="c1"># this is important</span>
    <span class="n">pprint</span><span class="p">(</span><span class="s1">&#39;l1=</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">l1</span><span class="p">))</span>
    <span class="n">pprint</span><span class="p">(</span><span class="s1">&#39;l2=</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">l2</span><span class="p">))</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">l1</span><span class="p">)):</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">l2</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">j</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">pass</span>
            <span class="k">elif</span> <span class="n">l1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="n">l2</span><span class="p">[</span><span class="n">j</span><span class="p">]:</span>
                <span class="n">strMatrix</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">strMatrix</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">],</span> <span class="n">strMatrix</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="n">j</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">strMatrix</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">strMatrix</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">l1</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">l2</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="n">pprint</span><span class="p">(</span><span class="n">strMatrix</span><span class="p">)</span>
    <span class="k">while</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">j</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">strMatrix</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">strMatrix</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]:</span>
            <span class="k">if</span> <span class="n">strMatrix</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">strMatrix</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="ow">and</span> <span class="n">strMatrix</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">strMatrix</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="n">j</span><span class="p">]:</span>
                <span class="n">retValue</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">l2</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
                <span class="n">j</span> <span class="o">-=</span> <span class="mi">1</span>
                <span class="n">i</span> <span class="o">-=</span> <span class="mi">1</span>
            <span class="k">elif</span> <span class="n">strMatrix</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">strMatrix</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="n">j</span><span class="p">]:</span>
                <span class="n">j</span> <span class="o">-=</span> <span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">i</span> <span class="o">-=</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">break</span>

    <span class="k">return</span> <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">retValue</span><span class="p">)[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>  <span class="c1"># To reverse string val[begin:end:-1] # begin, end - are left empty</span>


<span class="n">pprint</span><span class="p">(</span><span class="n">findLCSMethod</span><span class="p">(</span><span class="s1">&#39;abcdaf&#39;</span><span class="p">,</span> <span class="s1">&#39;acbcf&#39;</span><span class="p">))</span>
<span class="c1"># pprint(findLCSMethod(&#39;abc&#39;, &#39;abc&#39;))</span>
<span class="c1"># pprint(findLCSMethod(&#39;abc&#39;, &#39;def&#39;))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>&quot;l1=[&#39;&#39;, &#39;a&#39;, &#39;c&#39;, &#39;b&#39;, &#39;c&#39;, &#39;f&#39;]&quot;
&quot;l2=[&#39;&#39;, &#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;a&#39;, &#39;f&#39;]&quot;
[[0, 0, 0, 0, 0, 0, 0],
 [0, 1, 1, 1, 1, 1, 1],
 [0, 1, 1, 2, 2, 2, 2],
 [0, 1, 2, 2, 2, 2, 2],
 [0, 1, 2, 3, 3, 3, 3],
 [0, 1, 2, 3, 3, 3, 4]]
&#39;abcf&#39;
</pre></div>
</div>
</div>
</div>
</section>
<section id="fibonacci-number-6-ways">
<h4>Fibonacci number - 6 ways<a class="headerlink" href="#fibonacci-number-6-ways" title="Permalink to this headline">#</a></h4>
<ul class="simple">
<li><p>6 different ways of solving
0. Using recursion only</p>
<ol class="simple">
<li><p>Using recursion + local dictionary memoization</p></li>
<li><p>Using loop + memoization</p></li>
<li><p>Using recursion + decorator dictionary memoization</p></li>
<li><p>Using lru cache</p></li>
<li><p>Using matrix multiplication</p></li>
</ol>
</li>
</ul>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># %load ./pycharm/dp/fibonacci.py</span>
<span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">lru_cache</span>

<span class="c1"># class based decorator</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>


<span class="k">class</span> <span class="nc">MemoizeFib</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fn</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__mem</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__fn</span> <span class="o">=</span> <span class="n">fn</span>

    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">args</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__mem</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__mem</span><span class="p">[</span><span class="n">args</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__fn</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__mem</span><span class="p">[</span><span class="n">args</span><span class="p">]</span>

<span class="n">cache</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">:</span> <span class="mi">1</span><span class="p">}</span>
<span class="n">cache1</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">:</span> <span class="mi">1</span><span class="p">}</span>
<span class="n">cache2</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">:</span> <span class="mi">1</span><span class="p">}</span>

<span class="k">def</span> <span class="nf">fib0</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    :type n: nth fibonacci number</span>
<span class="sd">    :rtype: nth fibonacci number</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">cache</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">cache</span><span class="p">[</span><span class="n">n</span><span class="p">]</span>
    <span class="n">nocache</span> <span class="o">=</span> <span class="n">fib0</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">fib0</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">nocache</span>

<span class="k">def</span> <span class="nf">fib1</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    :type n: nth fibonacci number</span>
<span class="sd">    :rtype: nth fibonacci number</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">cache1</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">cache1</span><span class="p">[</span><span class="n">n</span><span class="p">]</span>
    <span class="n">cache1</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">fib1</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">fib1</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">cache1</span><span class="p">[</span><span class="n">n</span><span class="p">]</span>

<span class="k">def</span> <span class="nf">fib2</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
        <span class="n">cache2</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">cache2</span><span class="p">[</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">cache2</span><span class="p">[</span><span class="n">n</span> <span class="o">-</span> <span class="mi">2</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">cache2</span><span class="p">[</span><span class="n">n</span><span class="p">]</span>

<span class="nd">@MemoizeFib</span>
<span class="k">def</span> <span class="nf">fib3</span><span class="p">(</span><span class="n">num</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">num</span> <span class="ow">in</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">):</span>
        <span class="k">return</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="n">fib3</span><span class="p">(</span><span class="n">num</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">fib3</span><span class="p">(</span><span class="n">num</span><span class="o">-</span><span class="mi">2</span><span class="p">)</span>

<span class="nd">@lru_cache</span><span class="p">(</span><span class="n">maxsize</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">fib4</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">n</span>
    <span class="k">return</span> <span class="n">fib4</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">fib4</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">fib5</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
    <span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]])</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">return</span> <span class="mi">1</span>
    <span class="n">res</span> <span class="o">=</span> <span class="n">df</span>
    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
        <span class="n">res</span> <span class="o">=</span> <span class="n">res</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">df</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">res</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>


<span class="n">number</span> <span class="o">=</span> <span class="mi">20</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;fib0 - Using recursion only&#39;</span><span class="p">)</span>
<span class="o">%</span><span class="k">timeit</span> -r 7 -n 1000 fib0(number)
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;-------&#39;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;fib1 - Using recursion + local dictionary memoization&#39;</span><span class="p">)</span>
<span class="o">%</span><span class="k">timeit</span> -r 7 -n 1000 fib1(number)
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;-------&#39;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;fib2 - Using loop + memoization&#39;</span><span class="p">)</span>
<span class="o">%</span><span class="k">timeit</span> -r 7 -n 1000 fib2(number)
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;-------&#39;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;fib3 - Using recursion + decorator dictionary memoization&#39;</span><span class="p">)</span>
<span class="o">%</span><span class="k">timeit</span> -r 7 -n 1000 fib3(number)
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;-------&#39;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;fib4 - Using lru cache&#39;</span><span class="p">)</span>
<span class="o">%</span><span class="k">timeit</span> -r 7 -n 1000 fib4(number)
<span class="nb">print</span><span class="p">(</span><span class="n">fib4</span><span class="o">.</span><span class="n">cache_info</span><span class="p">())</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;-------&#39;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;fib5 - Using matrix multiplication&#39;</span><span class="p">)</span>
<span class="o">%</span><span class="k">timeit</span> -r 7 -n 1000 fib5(number)
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>fib0 - Using recursion only
</pre></div>
</div>
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>6.67 ms ± 477 µs per loop (mean ± std. dev. of 7 runs, 1,000 loops each)
-------
fib1 - Using recursion + local dictionary memoization
372 ns ± 164 ns per loop (mean ± std. dev. of 7 runs, 1,000 loops each)
-------
fib2 - Using loop + memoization
8.31 µs ± 1.75 µs per loop (mean ± std. dev. of 7 runs, 1,000 loops each)
-------
fib3 - Using recursion + decorator dictionary memoization
716 ns ± 219 ns per loop (mean ± std. dev. of 7 runs, 1,000 loops each)
-------
fib4 - Using lru cache
244 ns ± 143 ns per loop (mean ± std. dev. of 7 runs, 1,000 loops each)
CacheInfo(hits=7017, misses=21, maxsize=None, currsize=21)
-------
fib5 - Using matrix multiplication
</pre></div>
</div>
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>8.1 ms ± 194 µs per loop (mean ± std. dev. of 7 runs, 1,000 loops each)
</pre></div>
</div>
</div>
</div>
</section>
<section id="climbing-stairs-basic-scenario">
<h4>Climbing stairs - Basic scenario<a class="headerlink" href="#climbing-stairs-basic-scenario" title="Permalink to this headline">#</a></h4>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># %load ./pycharm/dp/climbing_stairs_01_basic.py</span>
<span class="k">class</span> <span class="nc">Solution</span><span class="p">():</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    You are climbing a staircase.It takes n steps to reach the top.</span>
<span class="sd">    Each time you can either climb 1 or 2 steps.</span>

<span class="sd">    In how many distinct ways can you climb to the top?</span>

<span class="sd">    Example 1:</span>
<span class="sd">        Input: n = 2 Output: 2</span>
<span class="sd">        Explanation: There are two ways to climb to the top.</span>
<span class="sd">            1. 1 step + 1 step</span>
<span class="sd">            2. 2 steps</span>

<span class="sd">    Example 2:</span>
<span class="sd">        Input: n = 3 Output: 3</span>
<span class="sd">        Explanation: There are three ways to climb to the top.</span>
<span class="sd">            1. 1 step + 1 step + 1 step</span>
<span class="sd">            2. 1 step + 2 steps</span>
<span class="sd">            3. 2 steps + 1 step</span>

<span class="sd">    Constraints:  1 &lt;= n &lt;= 45</span>
<span class="sd">    &#39;&#39;&#39;</span>

    <span class="k">def</span> <span class="nf">climbStairs_usingMemoization</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :type n: int</span>
<span class="sd">        :rtype: int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">arr</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">)]</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">climb</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">arr</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">climb</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">arr</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">a</span> <span class="o">&gt;</span> <span class="n">b</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="n">a</span> <span class="o">==</span> <span class="n">b</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">arr</span><span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">arr</span><span class="p">[</span><span class="n">a</span><span class="p">]</span>
        <span class="n">arr</span><span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">climb</span><span class="p">(</span><span class="n">a</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">arr</span><span class="p">)</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">climb</span><span class="p">(</span><span class="n">a</span> <span class="o">+</span> <span class="mi">2</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">arr</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">arr</span><span class="p">[</span><span class="n">a</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">climbStairs_usingDP</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :type n: int</span>
<span class="sd">        :rtype: int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">1</span>
        <span class="n">arr</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">)]</span>
        <span class="n">arr</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">arr</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">arr</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

<span class="n">s</span> <span class="o">=</span> <span class="n">Solution</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">climbStairs_usingMemoization</span><span class="p">(</span><span class="mi">5</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">climbStairs_usingDP</span><span class="p">(</span><span class="mi">5</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>8
8
</pre></div>
</div>
</div>
</div>
</section>
<section id="climbing-stairs-minimum">
<h4>Climbing stairs - minimum<a class="headerlink" href="#climbing-stairs-minimum" title="Permalink to this headline">#</a></h4>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># %load ./pycharm/dp/climbing_stairs_02_min.py</span>

<span class="k">class</span> <span class="nc">Solution</span><span class="p">():</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    You are given an integer array cost where cost[i] is the cost of ith step on a staircase.</span>
<span class="sd">    Once you pay the cost, you can either climb one or two steps.</span>

<span class="sd">    You can either start from the step with index 0, or the step with index 1.</span>

<span class="sd">    Return the minimum cost to reach the top of the floor.</span>

<span class="sd">    Example 1:</span>
<span class="sd">        Input: cost = [10,15,20]</span>
<span class="sd">        Output: 15</span>
<span class="sd">        Explanation: You will start at index 1.</span>
<span class="sd">            - Pay 15 and climb two steps to reach the top.</span>
<span class="sd">            The total cost is 15.</span>

<span class="sd">    Example 2:</span>
<span class="sd">        Input: cost = [1,100,1,1,1,100,1,1,100,1]</span>
<span class="sd">        Output: 6</span>
<span class="sd">        Explanation: You will start at index 0.</span>
<span class="sd">            - Pay 1 and climb two steps to reach index 2.</span>
<span class="sd">            - Pay 1 and climb two steps to reach index 4.</span>
<span class="sd">            - Pay 1 and climb two steps to reach index 6.</span>
<span class="sd">            - Pay 1 and climb one step to reach index 7.</span>
<span class="sd">            - Pay 1 and climb two steps to reach index 9.</span>
<span class="sd">            - Pay 1 and climb one step to reach the top.</span>
<span class="sd">            The total cost is 6.</span>

<span class="sd">    Constraints:</span>
<span class="sd">        2 &lt;= cost.length &lt;= 1000</span>
<span class="sd">        0 &lt;= cost[i] &lt;= 999</span>
<span class="sd">    &#39;&#39;&#39;</span>

    <span class="k">def</span> <span class="nf">minCostClimbingStairs_bottomup</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cost</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :type cost: List[int]</span>
<span class="sd">        :rtype: int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">minCost</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">cost</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">cost</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span> <span class="c1"># Cost of step 0 and 1 is 0</span>
            <span class="n">stepOne</span> <span class="o">=</span> <span class="n">minCost</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">cost</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">stepTwo</span> <span class="o">=</span> <span class="n">minCost</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="n">cost</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">2</span><span class="p">]</span>
            <span class="n">minCost</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">stepOne</span><span class="p">,</span> <span class="n">stepTwo</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">minCost</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="c1"># The cost of the top floor</span>


    <span class="k">def</span> <span class="nf">minCostClimbingStairs_topdown</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cost</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method solves the min cost problem using recursion and memoization</span>
<span class="sd">        :type cost: List[int]</span>
<span class="sd">        :rtype: int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">cache</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">def</span> <span class="nf">minCost</span><span class="p">(</span><span class="n">i</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">return</span> <span class="mi">0</span>
            <span class="k">if</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">cache</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">cache</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">stepOne</span> <span class="o">=</span> <span class="n">cost</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">minCost</span><span class="p">(</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">stepTwo</span> <span class="o">=</span> <span class="n">cost</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="n">minCost</span><span class="p">(</span><span class="n">i</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span>
            <span class="n">cache</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">stepOne</span><span class="p">,</span> <span class="n">stepTwo</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">cache</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">minCost</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">cost</span><span class="p">))</span>

<span class="c1"># cost = [10,15,20]</span>
<span class="n">cost</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">100</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">100</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">100</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
<span class="n">s</span> <span class="o">=</span> <span class="n">Solution</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">minCostClimbingStairs_bottomup</span><span class="p">(</span><span class="n">cost</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">minCostClimbingStairs_topdown</span><span class="p">(</span><span class="n">cost</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>6
6
</pre></div>
</div>
</div>
</div>
</section>
</section>
<section id="codechef-codeforces">
<h3>CodeChef/CodeForces<a class="headerlink" href="#codechef-codeforces" title="Permalink to this headline">#</a></h3>
<section id="good-pairs">
<h4>Good Pairs<a class="headerlink" href="#good-pairs" title="Permalink to this headline">#</a></h4>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># %load ./pycharm/general/GoodPair.py</span>
<span class="k">class</span> <span class="nc">GoodPair</span><span class="p">():</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    You are given arrays A and B of length N each. Determine the number of good pairs.</span>

<span class="sd">    A pair (i,j) (1≤i,j≤N) is said to be good if all of the following conditions are satisfied:</span>
<span class="sd">        i&lt;j;</span>
<span class="sd">        A_i=B_j;</span>
<span class="sd">        A_j=B_i;</span>

<span class="sd">    Input Format</span>
<span class="sd">        First line will contain T, the number of test cases. Then the test cases follow.</span>
<span class="sd">    Description of each test case:</span>
<span class="sd">        First line contains an integer N - denoting the length of the arrays.</span>
<span class="sd">        Second line contains N space-separated integers A1,A2,…AN - denoting the array A.</span>
<span class="sd">        Third line contains N space-separated integers B1,B2,…BN - denoting the array B.</span>
<span class="sd">    Output Format</span>
<span class="sd">        For each test case, output the number of good pairs.</span>
<span class="sd">    Constraints</span>
<span class="sd">        1 ≤ T ≤ 1000</span>
<span class="sd">        2 ≤ N ≤ 10^5</span>
<span class="sd">        1 ≤ A_i, B_i ≤ 10^9</span>
<span class="sd">        Sum of N over all test cases does not exceed 2⋅10^5.</span>

<span class="sd">    Sample Input 1</span>
<span class="sd">        4</span>
<span class="sd">        3</span>
<span class="sd">        1 2 3</span>
<span class="sd">        3 2 1</span>
<span class="sd">        4</span>
<span class="sd">        1 2 3 4</span>
<span class="sd">        5 6 6 7</span>
<span class="sd">        3</span>
<span class="sd">        10 10 10</span>
<span class="sd">        10 10 10</span>
<span class="sd">        4</span>
<span class="sd">        4 8 1 1</span>
<span class="sd">        8 4 1 1</span>
<span class="sd">    Sample Output 1</span>
<span class="sd">        1</span>
<span class="sd">        0</span>
<span class="sd">        3</span>
<span class="sd">        2</span>

<span class="sd">    Explanation</span>
<span class="sd">    Test Case 1: The only good pair (i,j) is (1,3). Here,</span>
<span class="sd">        1&lt;3</span>
<span class="sd">        A1=1 and B3=1. Thus, A1=B3.</span>
<span class="sd">        A3=3 and B1=3. Thus, A3=B1.</span>
<span class="sd">    Test Case 2: There are no good pairs.</span>
<span class="sd">    Test Case 3: There are 3 good pairs (i,j). These are (1,2),(1,3), and (2,3).</span>
<span class="sd">    Test Case 4: There are 2 good pairs (i,j). These are (1,2) and (3,4).</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">def</span> <span class="nf">findPairs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :type a: list A</span>
<span class="sd">        :type b: list B</span>
<span class="sd">        :rtype: number of pairs</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
        <span class="n">mp</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="n">ans</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
            <span class="n">temp</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="n">b</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span>

            <span class="k">if</span> <span class="n">mp</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">temp</span><span class="p">,</span> <span class="mi">0</span><span class="p">):</span>
                <span class="n">ans</span> <span class="o">=</span> <span class="n">ans</span> <span class="o">+</span> <span class="n">mp</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">temp</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;P1:i=</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">:ans=</span><span class="si">{</span><span class="n">ans</span><span class="si">}</span><span class="s2">:map=</span><span class="si">{</span><span class="n">mp</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

            <span class="n">temp</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">b</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="k">if</span> <span class="n">mp</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">temp</span><span class="p">,</span> <span class="mi">0</span><span class="p">):</span>
                <span class="n">mp</span><span class="p">[</span><span class="n">temp</span><span class="p">]</span> <span class="o">=</span> <span class="n">mp</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">temp</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;P2:i=</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">:ans=</span><span class="si">{</span><span class="n">ans</span><span class="si">}</span><span class="s2">:map=</span><span class="si">{</span><span class="n">mp</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">mp</span><span class="p">[</span><span class="n">temp</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;P3:i=</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">:ans=</span><span class="si">{</span><span class="n">ans</span><span class="si">}</span><span class="s2">:map=</span><span class="si">{</span><span class="n">mp</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">ans</span>

<span class="n">s</span> <span class="o">=</span> <span class="n">GoodPair</span><span class="p">()</span>
<span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">8</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
<span class="nb">print</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">findPairs</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">))</span>
<span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
<span class="nb">print</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">findPairs</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">))</span>
<span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">]</span>
<span class="nb">print</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">findPairs</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>P3:i=0:ans=0:map={&#39;8 4&#39;: 1}
P1:i=1:ans=1:map={&#39;8 4&#39;: 1}
P3:i=1:ans=1:map={&#39;8 4&#39;: 1, &#39;4 8&#39;: 1}
P3:i=2:ans=1:map={&#39;8 4&#39;: 1, &#39;4 8&#39;: 1, &#39;1 1&#39;: 1}
P1:i=3:ans=2:map={&#39;8 4&#39;: 1, &#39;4 8&#39;: 1, &#39;1 1&#39;: 1}
P2:i=3:ans=2:map={&#39;8 4&#39;: 1, &#39;4 8&#39;: 1, &#39;1 1&#39;: 2}
P1:i=4:ans=4:map={&#39;8 4&#39;: 1, &#39;4 8&#39;: 1, &#39;1 1&#39;: 2}
P2:i=4:ans=4:map={&#39;8 4&#39;: 1, &#39;4 8&#39;: 1, &#39;1 1&#39;: 3}
P1:i=5:ans=7:map={&#39;8 4&#39;: 1, &#39;4 8&#39;: 1, &#39;1 1&#39;: 3}
P2:i=5:ans=7:map={&#39;8 4&#39;: 1, &#39;4 8&#39;: 1, &#39;1 1&#39;: 4}
P1:i=6:ans=11:map={&#39;8 4&#39;: 1, &#39;4 8&#39;: 1, &#39;1 1&#39;: 4}
P2:i=6:ans=11:map={&#39;8 4&#39;: 1, &#39;4 8&#39;: 1, &#39;1 1&#39;: 5}
11
P3:i=0:ans=0:map={&#39;3 1&#39;: 1}
P3:i=1:ans=0:map={&#39;3 1&#39;: 1, &#39;2 2&#39;: 1}
P1:i=2:ans=1:map={&#39;3 1&#39;: 1, &#39;2 2&#39;: 1}
P3:i=2:ans=1:map={&#39;3 1&#39;: 1, &#39;2 2&#39;: 1, &#39;1 3&#39;: 1}
1
P3:i=0:ans=0:map={&#39;5 1&#39;: 1}
P3:i=1:ans=0:map={&#39;5 1&#39;: 1, &#39;6 2&#39;: 1}
P3:i=2:ans=0:map={&#39;5 1&#39;: 1, &#39;6 2&#39;: 1, &#39;6 3&#39;: 1}
P3:i=3:ans=0:map={&#39;5 1&#39;: 1, &#39;6 2&#39;: 1, &#39;6 3&#39;: 1, &#39;7 4&#39;: 1}
0
</pre></div>
</div>
</div>
</div>
</section>
<section id="most-similar-words">
<h4>Most Similar Words<a class="headerlink" href="#most-similar-words" title="Permalink to this headline">#</a></h4>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># %load ./pycharm/general/MostSimilarWords.py</span>
<span class="kn">import</span> <span class="nn">itertools</span>
<span class="kn">import</span> <span class="nn">math</span>


<span class="k">class</span> <span class="nc">MostSimilarWords</span><span class="p">():</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    You are given 𝑛 words of equal length 𝑚, consisting of lowercase Latin alphabet letters. The 𝑖-th word is</span>
<span class="sd">    denoted 𝑠𝑖.</span>

<span class="sd">    In one move you can choose any position in any single word and change the letter at that position to the</span>
<span class="sd">    previous or next letter in alphabetical order. For example:</span>
<span class="sd">      - you can change &#39;e&#39; to &#39;d&#39; or to &#39;f&#39;;</span>
<span class="sd">      - &#39;a&#39; can only be changed to &#39;b&#39;;</span>
<span class="sd">      - &#39;z&#39; can only be changed to &#39;y&#39;.</span>

<span class="sd">    The difference between two words is the minimum number of moves required to make them equal. For example, the</span>
<span class="sd">    difference between &quot;best&quot; and &quot;cost&quot; is 1+10+0+0=11.</span>

<span class="sd">    Find the minimum difference of 𝑠𝑖 and 𝑠𝑗 such that (𝑖&lt;𝑗). In other words, find the minimum difference over all</span>
<span class="sd">    possible pairs of the 𝑛 words.</span>

<span class="sd">    Input</span>
<span class="sd">      The first line of the input contains a single integer 𝑡 (1 ≤ 𝑡 ≤ 100) — the number of test cases. The</span>
<span class="sd">      description of test cases follows.</span>

<span class="sd">      The first line of each test case contains 2 integers 𝑛 and 𝑚 (2 ≤ 𝑛 ≤ 50, 1 ≤ 𝑚 ≤ 8) — the number of strings</span>
<span class="sd">      and their length respectively.</span>

<span class="sd">      Then follows 𝑛 lines, the 𝑖-th of which containing a single string 𝑠𝑖 of length 𝑚, consisting of lowercase</span>
<span class="sd">      Latin letters.</span>

<span class="sd">    Output</span>
<span class="sd">      For each test case, print a single integer — the minimum difference over all possible pairs of the</span>
<span class="sd">      given strings.</span>

<span class="sd">    Example:</span>
<span class="sd">        Input:</span>
<span class="sd">            6</span>
<span class="sd">            2 4</span>
<span class="sd">            best</span>
<span class="sd">            cost</span>
<span class="sd">            6 3</span>
<span class="sd">            abb</span>
<span class="sd">            zba</span>
<span class="sd">            bef</span>
<span class="sd">            cdu</span>
<span class="sd">            ooo</span>
<span class="sd">            zzz</span>
<span class="sd">            2 7</span>
<span class="sd">            aaabbbc</span>
<span class="sd">            bbaezfe</span>
<span class="sd">            3 2</span>
<span class="sd">            ab</span>
<span class="sd">            ab</span>
<span class="sd">            ab</span>
<span class="sd">            2 8</span>
<span class="sd">            aaaaaaaa</span>
<span class="sd">            zzzzzzzz</span>
<span class="sd">            3 1</span>
<span class="sd">            a</span>
<span class="sd">            u</span>
<span class="sd">            y</span>

<span class="sd">        Output:</span>
<span class="sd">            11</span>
<span class="sd">            8</span>
<span class="sd">            35</span>
<span class="sd">            0</span>
<span class="sd">            200</span>
<span class="sd">            4</span>

<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">def</span> <span class="nf">findWords</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">wordList</span><span class="p">):</span>
        <span class="n">minDiffValue</span><span class="p">,</span> <span class="n">minDiffTuple</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span> <span class="kc">None</span>
        <span class="k">for</span> <span class="n">couple</span> <span class="ow">in</span> <span class="n">itertools</span><span class="o">.</span><span class="n">combinations</span><span class="p">(</span><span class="n">wordList</span><span class="p">,</span> <span class="mi">2</span><span class="p">):</span>
            <span class="n">wordDiff</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">([</span><span class="nb">abs</span><span class="p">(</span><span class="nb">ord</span><span class="p">(</span><span class="n">ele1</span><span class="p">)</span> <span class="o">-</span> <span class="nb">ord</span><span class="p">(</span><span class="n">ele2</span><span class="p">))</span> <span class="k">for</span> <span class="n">ele1</span><span class="p">,</span> <span class="n">ele2</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">couple</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="nb">list</span><span class="p">(</span><span class="n">couple</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span> <span class="p">])</span>
            <span class="k">if</span> <span class="n">wordDiff</span> <span class="o">&lt;</span> <span class="n">minDiffValue</span><span class="p">:</span>
                <span class="n">minDiffValue</span><span class="p">,</span> <span class="n">minDiffTuple</span> <span class="o">=</span> <span class="n">wordDiff</span><span class="p">,</span> <span class="n">couple</span>
        <span class="k">return</span> <span class="p">{</span><span class="n">minDiffTuple</span><span class="p">:</span> <span class="n">minDiffValue</span><span class="p">}</span>

    <span class="k">def</span> <span class="nf">runner</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">wordList</span><span class="p">):</span>
        <span class="n">retValue</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">findWords</span><span class="p">(</span><span class="n">wordList</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">retValue</span><span class="p">)</span>

<span class="n">s</span> <span class="o">=</span> <span class="n">MostSimilarWords</span><span class="p">()</span>
<span class="n">s</span><span class="o">.</span><span class="n">runner</span><span class="p">([</span><span class="s1">&#39;best&#39;</span><span class="p">,</span> <span class="s1">&#39;cost&#39;</span><span class="p">])</span>
<span class="n">s</span><span class="o">.</span><span class="n">runner</span><span class="p">([</span><span class="s1">&#39;abb&#39;</span><span class="p">,</span> <span class="s1">&#39;zba&#39;</span><span class="p">,</span> <span class="s1">&#39;bef&#39;</span><span class="p">,</span> <span class="s1">&#39;cdu&#39;</span><span class="p">,</span> <span class="s1">&#39;ooo&#39;</span><span class="p">,</span> <span class="s1">&#39;zzz&#39;</span><span class="p">])</span>
<span class="n">s</span><span class="o">.</span><span class="n">runner</span><span class="p">([</span><span class="s1">&#39;aaabbbc&#39;</span><span class="p">,</span> <span class="s1">&#39;bbaezfe&#39;</span><span class="p">])</span>
<span class="n">s</span><span class="o">.</span><span class="n">runner</span><span class="p">([</span><span class="s1">&#39;aaaaaaaa&#39;</span><span class="p">,</span> <span class="s1">&#39;zzzzzzzz&#39;</span><span class="p">])</span>
<span class="n">s</span><span class="o">.</span><span class="n">runner</span><span class="p">([</span><span class="s1">&#39;ab&#39;</span><span class="p">,</span> <span class="s1">&#39;ab&#39;</span><span class="p">,</span> <span class="s1">&#39;ab&#39;</span><span class="p">])</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>{(&#39;best&#39;, &#39;cost&#39;): 11}
{(&#39;abb&#39;, &#39;bef&#39;): 8}
{(&#39;aaabbbc&#39;, &#39;bbaezfe&#39;): 35}
{(&#39;aaaaaaaa&#39;, &#39;zzzzzzzz&#39;): 200}
{(&#39;ab&#39;, &#39;ab&#39;): 0}
</pre></div>
</div>
</div>
</div>
</section>
</section>
</section>
<section id="c">
<h2>C++<a class="headerlink" href="#c" title="Permalink to this headline">#</a></h2>
<section id="sliding-window">
<h3>Sliding Window<a class="headerlink" href="#sliding-window" title="Permalink to this headline">#</a></h3>
<section id="average-of-subarray-of-m-elements-brute-force">
<h4>Average of subarray of m elements (Brute force)<a class="headerlink" href="#average-of-subarray-of-m-elements-brute-force" title="Permalink to this headline">#</a></h4>
<ul class="simple">
<li><p>Time complexity is O(nxm) where n is the number of elements and m is the number of subarray elements</p></li>
</ul>
<p><strong># %load ./cpp/slidingWindow/SubArrayAverage.cpp</strong></p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;vector&gt;</span><span class="cp"></span>
<span class="k">using</span><span class="w"> </span><span class="k">namespace</span><span class="w"> </span><span class="nn">std</span><span class="p">;</span><span class="w"></span>


<span class="k">class</span><span class="w"> </span><span class="nc">SubArrayAverage</span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">public</span><span class="o">:</span><span class="w"></span>
<span class="w">        </span><span class="k">static</span><span class="w"> </span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="w"> </span><span class="n">findAverage</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">subArraySize</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">arr</span><span class="p">){</span><span class="w"></span>
<span class="w">            </span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="w"> </span><span class="n">result</span><span class="p">(</span><span class="n">arr</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">subArraySize</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span><span class="w"></span>
<span class="w">            </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">arr</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="o">-</span><span class="n">subArraySize</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">){</span><span class="w"></span>
<span class="w">                </span><span class="kt">double</span><span class="w"> </span><span class="n">sum</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">                </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">j</span><span class="o">=</span><span class="n">i</span><span class="p">;</span><span class="w"> </span><span class="n">j</span><span class="o">&lt;</span><span class="n">i</span><span class="o">+</span><span class="n">subArraySize</span><span class="p">;</span><span class="w"> </span><span class="n">j</span><span class="o">++</span><span class="p">){</span><span class="w"></span>
<span class="w">                    </span><span class="n">sum</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">arr</span><span class="p">[</span><span class="n">j</span><span class="p">];</span><span class="w"></span>
<span class="w">                </span><span class="p">}</span><span class="w"></span>
<span class="w">                </span><span class="n">result</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sum</span><span class="o">/</span><span class="n">subArraySize</span><span class="p">;</span><span class="w"></span>
<span class="w">            </span><span class="p">}</span><span class="w"></span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="n">result</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">argc</span><span class="p">,</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">argv</span><span class="p">[]){</span><span class="w"></span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">subArraySize</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">5</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">arr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="mi">6</span><span class="p">,</span><span class="w"> </span><span class="mi">7</span><span class="p">,</span><span class="w"> </span><span class="mi">8</span><span class="p">,</span><span class="w"> </span><span class="mi">9</span><span class="p">,</span><span class="w"> </span><span class="mi">10</span><span class="w"> </span><span class="p">};</span><span class="w"></span>
<span class="w">    </span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">SubArrayAverage</span><span class="o">::</span><span class="n">findAverage</span><span class="p">(</span><span class="n">subArraySize</span><span class="p">,</span><span class="w"> </span><span class="n">arr</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Average of array with subarrays of size &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">subArraySize</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot; is &quot;</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">double</span><span class="w"> </span><span class="n">d</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">result</span><span class="p">){</span><span class="w"></span>
<span class="w">        </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">d</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot; &quot;</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">endl</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="o">!</span>./cpp/slidingWindow/SubArrayAverage
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Average of array with subarrays of size 5 is 3 4 5 6 7 8 
</pre></div>
</div>
</div>
</div>
</section>
<section id="average-of-subarray-of-m-elements-sliding-window">
<h4>Average of subarray of m elements (Sliding Window)<a class="headerlink" href="#average-of-subarray-of-m-elements-sliding-window" title="Permalink to this headline">#</a></h4>
<ul class="simple">
<li><p>Time complexity is O(n) where n is the number of elements and m is the number of subarray elements</p></li>
</ul>
<p><strong># %load ./cpp/slidingWindow/SubArrayAverage2.cpp</strong></p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;vector&gt;</span><span class="cp"></span>
<span class="k">using</span><span class="w"> </span><span class="k">namespace</span><span class="w"> </span><span class="nn">std</span><span class="p">;</span><span class="w"></span>


<span class="k">class</span><span class="w"> </span><span class="nc">SubArrayAverage2</span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">public</span><span class="o">:</span><span class="w"></span>
<span class="w">        </span><span class="k">static</span><span class="w"> </span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="w"> </span><span class="n">findAverage</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">subArraySize</span><span class="p">,</span><span class="w"> </span><span class="n">cacheonst</span><span class="w"> </span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">arr</span><span class="p">){</span><span class="w"></span>
<span class="w">            </span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="w"> </span><span class="n">result</span><span class="p">(</span><span class="n">arr</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">subArraySize</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span><span class="w"></span>
<span class="w">            </span><span class="kt">int</span><span class="w"> </span><span class="n">slidingWindow</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">            </span><span class="kt">double</span><span class="w"> </span><span class="n">sum</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">            </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">arr</span><span class="p">.</span><span class="n">size</span><span class="p">();</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">){</span><span class="w"></span>
<span class="w">                </span><span class="n">slidingWindow</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"></span>
<span class="w">                </span><span class="n">sum</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">];</span><span class="w"></span>
<span class="w">                </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">slidingWindow</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="n">subArraySize</span><span class="p">){</span><span class="w"></span>
<span class="w">                    </span><span class="n">result</span><span class="p">[</span><span class="n">i</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">subArraySize</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sum</span><span class="o">/</span><span class="n">subArraySize</span><span class="p">;</span><span class="w"></span>
<span class="w">                    </span><span class="n">sum</span><span class="w"> </span><span class="o">-=</span><span class="w"> </span><span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">subArraySize</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">];</span><span class="w"></span>
<span class="w">                </span><span class="p">}</span><span class="w"></span>
<span class="w">            </span><span class="p">}</span><span class="w"></span>

<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="n">result</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">argc</span><span class="p">,</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">argv</span><span class="p">[]){</span><span class="w"></span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">subArraySize</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">5</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">arr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="mi">6</span><span class="p">,</span><span class="w"> </span><span class="mi">7</span><span class="p">,</span><span class="w"> </span><span class="mi">8</span><span class="p">,</span><span class="w"> </span><span class="mi">9</span><span class="p">,</span><span class="w"> </span><span class="mi">10</span><span class="w"> </span><span class="p">};</span><span class="w"></span>
<span class="w">    </span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">SubArrayAverage2</span><span class="o">::</span><span class="n">findAverage</span><span class="p">(</span><span class="n">subArraySize</span><span class="p">,</span><span class="w"> </span><span class="n">arr</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Average of array with subarrays of size &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">subArraySize</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot; is &quot;</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">double</span><span class="w"> </span><span class="n">d</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">result</span><span class="p">){</span><span class="w"></span>
<span class="w">        </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">d</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot; &quot;</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">endl</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="o">!</span>./cpp/slidingWindow/SubArrayAverage2
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Average of array with subarrays of size 5 is 3 4 5 6 7 8 
</pre></div>
</div>
</div>
</div>
</section>
<section id="longest-substring-with-k-distinct-characters">
<h4>Longest substring with k distinct characters<a class="headerlink" href="#longest-substring-with-k-distinct-characters" title="Permalink to this headline">#</a></h4>
<ul class="simple">
<li><p>Time complexity is O(n+n) asymptotically equivalent to O(n) where n is the number of elements</p></li>
</ul>
<p><strong># %load ./cpp/slidingWindow/LongestSubStringKChar.cpp</strong></p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;string&gt;</span><span class="cp"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;unordered_map&gt;</span><span class="cp"></span>
<span class="k">using</span><span class="w"> </span><span class="k">namespace</span><span class="w"> </span><span class="nn">std</span><span class="p">;</span><span class="w"></span>

<span class="k">class</span><span class="w"> </span><span class="nc">Log</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="k">public</span><span class="o">:</span><span class="w"></span>
<span class="w">    </span><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span><span class="w"></span>
<span class="w">    </span><span class="n">Log</span><span class="o">&amp;</span><span class="w"> </span><span class="k">operator</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">T</span><span class="o">&amp;</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="cp">#ifdef DEBUG_MODE</span>
<span class="w">        </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">x</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="cp">#endif</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="o">*</span><span class="k">this</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>

<span class="n">Log</span><span class="w"> </span><span class="n">mycout</span><span class="p">;</span><span class="w"></span>

<span class="cm">/*</span>
<span class="cm">Given a string, find the length of the longest substring in it with no more than K distinct characters.</span>
<span class="cm">*/</span><span class="w"></span>
<span class="k">class</span><span class="w"> </span><span class="nc">LongestSubStringKDistinctChar</span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">public</span><span class="o">:</span><span class="w"></span>
<span class="w">        </span><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">K</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">V</span><span class="o">&gt;</span><span class="w"></span>
<span class="w">        </span><span class="k">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">print_map</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">unordered_map</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span><span class="w"> </span><span class="n">V</span><span class="o">&gt;</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="o">&amp;</span><span class="n">m</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="k">auto</span><span class="w"> </span><span class="n">it</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">m</span><span class="p">.</span><span class="n">cbegin</span><span class="p">();</span><span class="w"> </span><span class="n">it</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">m</span><span class="p">.</span><span class="n">cend</span><span class="p">();</span><span class="w"> </span><span class="o">++</span><span class="n">it</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                </span><span class="n">mycout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;{&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">it</span><span class="p">).</span><span class="n">first</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;: &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">it</span><span class="p">).</span><span class="n">second</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;}&quot;</span><span class="p">;</span><span class="w"></span>
<span class="w">            </span><span class="p">}</span><span class="w"></span>
<span class="w">            </span><span class="n">mycout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="k">static</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="n">string</span><span class="o">&gt;</span><span class="w"> </span><span class="n">distinctChar</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">string</span><span class="w"> </span><span class="o">&amp;</span><span class="n">st</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">k</span><span class="p">){</span><span class="w"></span>
<span class="w">            </span><span class="c1">// declare start of sliding window, </span>
<span class="w">            </span><span class="c1">//         maximum distinct k char substring, </span>
<span class="w">            </span><span class="c1">//         maximum substring length and </span>
<span class="w">            </span><span class="c1">//         an unordered map that holds distinct character and its count</span>
<span class="w">            </span><span class="kt">int</span><span class="w"> </span><span class="n">windowStart</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">            </span><span class="n">string</span><span class="w"> </span><span class="n">maxSubstr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;&quot;</span><span class="p">;</span><span class="w"></span>
<span class="w">            </span><span class="kt">int</span><span class="w"> </span><span class="n">maxLen</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">            </span><span class="n">unordered_map</span><span class="o">&lt;</span><span class="kt">char</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">cMap</span><span class="p">;</span><span class="w"></span>
<span class="w">            </span>
<span class="w">            </span><span class="c1">// loop over the string sliding end of the window one character at a time</span>
<span class="w">            </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">windowEnd</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">windowEnd</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">st</span><span class="p">.</span><span class="n">length</span><span class="p">();</span><span class="w"> </span><span class="n">windowEnd</span><span class="o">++</span><span class="p">){</span><span class="w"></span>
<span class="w">                </span><span class="n">mycout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Loop &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">windowEnd</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span><span class="w"></span>
<span class="w">                </span><span class="c1">// hold current character of the string</span>
<span class="w">                </span><span class="kt">char</span><span class="w"> </span><span class="n">cChar</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">st</span><span class="p">[</span><span class="n">windowEnd</span><span class="p">];</span><span class="w"></span>
<span class="w">                </span><span class="c1">// increment the map with the current character</span>
<span class="w">                </span><span class="n">cMap</span><span class="p">[</span><span class="n">cChar</span><span class="p">]</span><span class="o">++</span><span class="p">;</span><span class="w"></span>

<span class="w">                </span><span class="c1">// move start of the sliding window if the map size exceeds the k length</span>
<span class="w">                </span><span class="c1">// keep moving the start end of sliding window till it map resizes as per k length</span>
<span class="w">                </span><span class="n">print_map</span><span class="p">(</span><span class="n">cMap</span><span class="p">);</span><span class="w"></span>

<span class="w">                </span><span class="k">while</span><span class="p">((</span><span class="kt">int</span><span class="p">)</span><span class="n">cMap</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">k</span><span class="p">){</span><span class="w"></span>
<span class="w">                    </span><span class="n">mycout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;cMap size &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">cMap</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span><span class="w"></span>
<span class="w">                    </span><span class="kt">char</span><span class="w"> </span><span class="n">lChar</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">st</span><span class="p">[</span><span class="n">windowStart</span><span class="p">];</span><span class="w"></span>
<span class="w">                    </span><span class="c1">//cout &lt;&lt; &quot;lChar &quot; &lt;&lt; lChar;</span>
<span class="w">                    </span><span class="n">cMap</span><span class="p">[</span><span class="n">lChar</span><span class="p">]</span><span class="o">--</span><span class="p">;</span><span class="w"></span>
<span class="w">                    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">cMap</span><span class="p">[</span><span class="n">lChar</span><span class="p">]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                        </span><span class="n">cMap</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">lChar</span><span class="p">);</span><span class="w"></span>
<span class="w">                    </span><span class="p">}</span><span class="w"></span>
<span class="w">                    </span><span class="c1">// shrink the window</span>
<span class="w">                    </span><span class="n">windowStart</span><span class="o">++</span><span class="p">;</span><span class="w"></span>
<span class="w">                </span><span class="p">}</span><span class="w"></span>
<span class="w">                </span><span class="n">print_map</span><span class="p">(</span><span class="n">cMap</span><span class="p">);</span><span class="w"></span>

<span class="w">                </span><span class="c1">// recalculate the max distinct k character substring</span>
<span class="w">                </span><span class="kt">int</span><span class="w"> </span><span class="n">calcMax</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">max</span><span class="p">(</span><span class="n">maxLen</span><span class="p">,</span><span class="w"> </span><span class="n">windowEnd</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">windowStart</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span><span class="w"></span>
<span class="w">                </span><span class="k">if</span><span class="p">(</span><span class="n">calcMax</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">maxLen</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                    </span><span class="n">maxSubstr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">st</span><span class="p">.</span><span class="n">substr</span><span class="p">(</span><span class="n">windowStart</span><span class="p">,</span><span class="w"> </span><span class="n">windowEnd</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">windowStart</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span><span class="w"></span>
<span class="w">                    </span><span class="c1">// recalculate the max length of k character substring</span>
<span class="w">                    </span><span class="n">maxLen</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">calcMax</span><span class="p">;</span><span class="w"></span>
<span class="w">                </span><span class="p">}</span><span class="w"></span>
<span class="w">            </span><span class="p">}</span><span class="w"></span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">make_pair</span><span class="p">(</span><span class="n">maxLen</span><span class="p">,</span><span class="w"> </span><span class="n">maxSubstr</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">argc</span><span class="p">,</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">argv</span><span class="p">[]){</span><span class="w"></span>
<span class="w">    </span><span class="n">string</span><span class="w"> </span><span class="n">st</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;abcccdde&quot;</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="c1">// cout &lt;&lt; st &lt;&lt; endl; </span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="n">string</span><span class="o">&gt;</span><span class="w"> </span><span class="n">re</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">LongestSubStringKDistinctChar</span><span class="o">::</span><span class="n">distinctChar</span><span class="p">(</span><span class="n">st</span><span class="p">,</span><span class="w"> </span><span class="n">k</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Longest substring of length &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot; distinct char in &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">st</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot; is &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">re</span><span class="p">.</span><span class="n">second</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot; of length &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">re</span><span class="p">.</span><span class="n">first</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">endl</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="o">!</span>./cpp/slidingWindow/LongestSubStringKChar
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Loop 0
{a: 1}
{a: 1}
Loop 1
{b: 1}{a: 1}
{b: 1}{a: 1}
Loop 2
{c: 1}{b: 1}{a: 1}
cMap size 3
{c: 1}{b: 1}
Loop 3
{c: 2}{b: 1}
{c: 2}{b: 1}
Loop 4
{c: 3}{b: 1}
{c: 3}{b: 1}
Loop 5
{d: 1}{c: 3}{b: 1}
cMap size 3
{d: 1}{c: 3}
Loop 6
{d: 2}{c: 3}
{d: 2}{c: 3}
Loop 7
{e: 1}{d: 2}{c: 3}
cMap size 3
cMap size 3
cMap size 3
{e: 1}{d: 2}
Longest substring of length 2 distinct char in abcccdde is cccdd of length 5
</pre></div>
</div>
</div>
</div>
</section>
</section>
<section id="two-pointers">
<h3>Two pointers<a class="headerlink" href="#two-pointers" title="Permalink to this headline">#</a></h3>
<section id="remove-duplicates">
<h4>Remove duplicates<a class="headerlink" href="#remove-duplicates" title="Permalink to this headline">#</a></h4>
<p><strong># %load ./cpp/twoPointers/removeAllDuplicates.cpp</strong></p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>
<span class="cp">#include</span><span class="cpf">&lt;vector&gt;</span><span class="cp"></span>

<span class="k">using</span><span class="w"> </span><span class="k">namespace</span><span class="w"> </span><span class="nn">std</span><span class="p">;</span><span class="w"></span>

<span class="cm">/*</span>
<span class="cm">Given an array of sorted numbers, remove all duplicates from it. You should not use any extra space; after removing the duplicates in-place return the length of the subarray that has no duplicate in it.</span>

<span class="cm">Example 1:</span>
<span class="cm">Input: [2, 3, 3, 3, 6, 9, 9]</span>
<span class="cm">Output: 4</span>
<span class="cm">Explanation: The first four elements after removing the duplicates will be [2, 3, 6, 9].</span>

<span class="cm">Example 2:</span>
<span class="cm">Input: [2, 2, 2, 11]</span>
<span class="cm">Output: 2</span>
<span class="cm">Explanation: The first two elements after removing the duplicates will be [2, 11].</span>
<span class="cm">*/</span><span class="w"></span>

<span class="k">class</span><span class="w"> </span><span class="nc">RemoveAllDuplicates</span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">public</span><span class="o">:</span><span class="w"></span>
<span class="w">        </span><span class="k">static</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">remove</span><span class="p">(</span><span class="n">vector</span><span class="w"> </span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">arr</span><span class="p">){</span><span class="w"></span>
<span class="w">            </span><span class="kt">int</span><span class="w"> </span><span class="n">nextElement</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"></span>
<span class="w">            </span>
<span class="w">            </span><span class="c1">//for (auto i=0; i&lt;arr.size(); i++){</span>
<span class="w">            </span><span class="k">for</span><span class="p">(</span><span class="k">auto</span><span class="w"> </span><span class="n">i</span><span class="o">:</span><span class="w"> </span><span class="n">arr</span><span class="p">){</span><span class="w"></span>
<span class="w">                </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">arr</span><span class="p">[</span><span class="n">nextElement</span><span class="mi">-1</span><span class="p">]</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]){</span><span class="w"></span>
<span class="w">                    </span><span class="n">arr</span><span class="p">[</span><span class="n">nextElement</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">];</span><span class="w"></span>
<span class="w">                    </span><span class="n">nextElement</span><span class="o">++</span><span class="p">;</span><span class="w"></span>
<span class="w">                </span><span class="p">}</span><span class="w"></span>
<span class="w">            </span><span class="p">}</span><span class="w"></span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="n">nextElement</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>

<span class="p">};</span><span class="w"></span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">(){</span><span class="w"></span>
<span class="w">    </span><span class="n">vector</span><span class="w"> </span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">arr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">6</span><span class="p">};</span><span class="w"></span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">c</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="n">RemoveAllDuplicates</span><span class="o">::</span><span class="n">remove</span><span class="p">(</span><span class="n">arr</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot; - &quot;</span><span class="w">  </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">endl</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">for</span><span class="p">(</span><span class="k">auto</span><span class="w"> </span><span class="n">i</span><span class="o">:</span><span class="w"> </span><span class="n">arr</span><span class="p">){</span><span class="w"></span>
<span class="w">    </span><span class="c1">//for (int i=0; i&lt;arr.size(); i++){</span>
<span class="w">        </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="sc">&#39; &#39;</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">endl</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="o">!</span>./cpp/twoPointers/removeAllDuplicates
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>4 - 
4 6 4 6 4 4 6 
</pre></div>
</div>
</div>
</div>
</section>
<section id="square-sorted-array">
<h4>Square sorted array<a class="headerlink" href="#square-sorted-array" title="Permalink to this headline">#</a></h4>
<p>`# %load ./cpp/twoPointers/squareSortedArray.cpp</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;vector&gt;</span><span class="cp"></span>

<span class="k">using</span><span class="w"> </span><span class="k">namespace</span><span class="w"> </span><span class="nn">std</span><span class="p">;</span><span class="w"></span>

<span class="cm">/*</span>
<span class="cm">Given a sorted array, create a new array containing squares of all the numbers of the input array in the sorted order.</span>

<span class="cm">Example 1:</span>
<span class="cm">Input: [-2, -1, 0, 2, 3]</span>
<span class="cm">Output: [0, 1, 4, 4, 9]</span>

<span class="cm">Example 2:</span>
<span class="cm">Input: [-3, -1, 0, 1, 2]</span>
<span class="cm">Output: [0, 1, 1, 4, 9]</span>
<span class="cm">*/</span><span class="w"></span>

<span class="k">class</span><span class="w"> </span><span class="nc">SortedArraySquares</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w"> </span><span class="k">public</span><span class="o">:</span><span class="w"></span>
<span class="w">  </span><span class="k">static</span><span class="w"> </span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">makeSquares</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">arr</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">arr</span><span class="p">.</span><span class="n">size</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">squares</span><span class="p">(</span><span class="n">n</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">left</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">right</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">n</span><span class="mi">-1</span><span class="p">,</span><span class="w"> </span><span class="n">lastIndex</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">n</span><span class="mi">-1</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">leftSq</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">rightSq</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">while</span><span class="p">(</span><span class="n">left</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">right</span><span class="p">){</span><span class="w"></span>
<span class="w">        </span><span class="n">leftSq</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">arr</span><span class="p">[</span><span class="n">left</span><span class="p">]</span><span class="o">*</span><span class="w"> </span><span class="n">arr</span><span class="p">[</span><span class="n">left</span><span class="p">];</span><span class="w"></span>
<span class="w">        </span><span class="n">rightSq</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">arr</span><span class="p">[</span><span class="n">right</span><span class="p">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">arr</span><span class="p">[</span><span class="n">right</span><span class="p">];</span><span class="w"></span>
<span class="w">        </span><span class="k">if</span><span class="p">(</span><span class="n">leftSq</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">rightSq</span><span class="p">){</span><span class="w"></span>
<span class="w">            </span><span class="n">squares</span><span class="p">[</span><span class="n">lastIndex</span><span class="o">--</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">rightSq</span><span class="p">;</span><span class="w"></span>
<span class="w">            </span><span class="n">right</span><span class="o">--</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="k">else</span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="n">squares</span><span class="p">[</span><span class="n">lastIndex</span><span class="o">--</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">leftSq</span><span class="p">;</span><span class="w"></span>
<span class="w">            </span><span class="n">left</span><span class="o">++</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">squares</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">(){</span><span class="w"></span>
<span class="w">    </span><span class="c1">//vector&lt;int&gt; arr = {-2, -1, 0, 2, 3};</span>
<span class="w">    </span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">arr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="mi">-2</span><span class="p">,</span><span class="w"> </span><span class="mi">-1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">};</span><span class="w"></span>
<span class="w">    </span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">res</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">SortedArraySquares</span><span class="o">::</span><span class="n">makeSquares</span><span class="p">(</span><span class="n">arr</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Original Array: &quot;</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">for</span><span class="p">(</span><span class="k">auto</span><span class="w"> </span><span class="n">i</span><span class="o">:</span><span class="w"> </span><span class="n">arr</span><span class="p">){</span><span class="w"></span>
<span class="w">        </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot; &quot;</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">endl</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Squared Array: &quot;</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">for</span><span class="p">(</span><span class="k">auto</span><span class="w"> </span><span class="n">i</span><span class="o">:</span><span class="w"> </span><span class="n">res</span><span class="p">){</span><span class="w"></span>
<span class="w">        </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot; &quot;</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">endl</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="o">!</span> ./cpp/twoPointers/squareSortedArray
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Original Array: -2 -1 1 2 
Squared Array: 1 1 4 4 
</pre></div>
</div>
</div>
</div>
</section>
</section>
<section id="fast-and-slow-pointers">
<h3>Fast and Slow Pointers<a class="headerlink" href="#fast-and-slow-pointers" title="Permalink to this headline">#</a></h3>
<section id="linked-list-cycle">
<h4>Linked List Cycle<a class="headerlink" href="#linked-list-cycle" title="Permalink to this headline">#</a></h4>
<p>`# %load ./cpp/fastSlowPointers/linkedListCycle.cpp</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>
<span class="k">using</span><span class="w"> </span><span class="k">namespace</span><span class="w"> </span><span class="nn">std</span><span class="p">;</span><span class="w"></span>

<span class="cm">/*</span>
<span class="cm">Given the head of a Singly LinkedList, write a function to determine if the LinkedList has a cycle in it or not.</span>
<span class="cm">Hint:</span>
<span class="cm">- the fast pointer moves 2 steps at a time</span>
<span class="cm">- the slow pointer moves 1 step at a time </span>
<span class="cm">*/</span><span class="w"></span>
<span class="k">class</span><span class="w"> </span><span class="nc">Node</span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">public</span><span class="o">:</span><span class="w"></span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="n">Node</span><span class="w"> </span><span class="o">*</span><span class="n">next</span><span class="p">;</span><span class="w"></span>

<span class="w">        </span><span class="n">Node</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">value</span><span class="p">){</span><span class="w"></span>
<span class="w">            </span><span class="k">this</span><span class="o">-&gt;</span><span class="n">value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">value</span><span class="p">;</span><span class="w"></span>
<span class="w">            </span><span class="n">next</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">nullptr</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>

<span class="k">class</span><span class="w"> </span><span class="nc">LLCycle</span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">public</span><span class="o">:</span><span class="w"></span>
<span class="w">        </span><span class="k">static</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">detectCycle</span><span class="p">(</span><span class="n">Node</span><span class="w"> </span><span class="o">*</span><span class="n">head</span><span class="p">){</span><span class="w"></span>
<span class="w">            </span><span class="n">Node</span><span class="w"> </span><span class="o">*</span><span class="n">slow</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">head</span><span class="p">;</span><span class="w"></span>
<span class="w">            </span><span class="n">Node</span><span class="w"> </span><span class="o">*</span><span class="n">fast</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">head</span><span class="p">;</span><span class="w"></span>
<span class="w">            </span><span class="k">while</span><span class="p">(</span><span class="n">fast</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="k">nullptr</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">fast</span><span class="o">-&gt;</span><span class="n">next</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="k">nullptr</span><span class="p">){</span><span class="w"></span>
<span class="w">                </span><span class="n">fast</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fast</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span><span class="w"></span>
<span class="w">                </span><span class="n">slow</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">slow</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span><span class="w"></span>
<span class="w">                </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">fast</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">slow</span><span class="p">){</span><span class="w"></span>
<span class="w">                    </span><span class="k">return</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span><span class="w"></span>
<span class="w">                </span><span class="p">}</span><span class="w"></span>
<span class="w">            </span><span class="p">}</span><span class="w"></span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">(){</span><span class="w"></span>
<span class="w">    </span><span class="n">Node</span><span class="w"> </span><span class="o">*</span><span class="n">head</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">Node</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">head</span><span class="o">-&gt;</span><span class="n">next</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">Node</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">head</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">next</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">Node</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">head</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">next</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">Node</span><span class="p">(</span><span class="mi">4</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">head</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">next</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">Node</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">head</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">next</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">Node</span><span class="p">(</span><span class="mi">6</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;LL1 has cycle: &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">LLCycle</span><span class="o">::</span><span class="n">detectCycle</span><span class="p">(</span><span class="n">head</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">endl</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span>
<span class="w">    </span><span class="n">head</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">next</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">head</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;LL2 has cycle: &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">LLCycle</span><span class="o">::</span><span class="n">detectCycle</span><span class="p">(</span><span class="n">head</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">endl</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="o">!</span> ./cpp/fastSlowPointers/linkedListCycle
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>LL1 has cycle: 0
LL2 has cycle: 1
</pre></div>
</div>
</div>
</div>
</section>
<section id="head-of-the-linked-list-cycle">
<h4>Head of the linked list cycle<a class="headerlink" href="#head-of-the-linked-list-cycle" title="Permalink to this headline">#</a></h4>
<p>`# %load ./cpp/fastSlowPointers/linkedListCycleHead.cpp</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>

<span class="k">using</span><span class="w"> </span><span class="k">namespace</span><span class="w"> </span><span class="nn">std</span><span class="p">;</span><span class="w"></span>

<span class="cm">/*</span>
<span class="cm">Given the head of a Singly LinkedList that contains a cycle, write a function to find the starting node of the cycle.</span>
<span class="cm">*/</span><span class="w"></span>
<span class="k">class</span><span class="w"> </span><span class="nc">Node</span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">public</span><span class="o">:</span><span class="w"></span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">Node</span><span class="w"> </span><span class="o">*</span><span class="n">next</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">nullptr</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="n">Node</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">value</span><span class="p">){</span><span class="w"></span>
<span class="w">        </span><span class="k">this</span><span class="o">-&gt;</span><span class="n">value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">value</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="n">next</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">nullptr</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>

<span class="k">class</span><span class="w"> </span><span class="nc">LLCycleHead</span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">public</span><span class="o">:</span><span class="w"></span>
<span class="w">    </span><span class="k">static</span><span class="w"> </span><span class="n">Node</span><span class="w"> </span><span class="o">*</span><span class="n">identifyCycleHead</span><span class="p">(</span><span class="n">Node</span><span class="w"> </span><span class="o">*</span><span class="n">head</span><span class="p">){</span><span class="w"></span>
<span class="w">        </span><span class="n">Node</span><span class="w"> </span><span class="o">*</span><span class="n">slow</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">head</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">fast</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">head</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">cycleLength</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="k">while</span><span class="p">(</span><span class="n">fast</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="k">nullptr</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">fast</span><span class="o">-&gt;</span><span class="n">next</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="k">nullptr</span><span class="p">){</span><span class="w"></span>
<span class="w">            </span><span class="n">fast</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fast</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span><span class="w"></span>
<span class="w">            </span><span class="n">slow</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">slow</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span><span class="w"></span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">fast</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">slow</span><span class="p">){</span><span class="w"></span>
<span class="w">                </span><span class="n">cycleLength</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">calculateCycleLength</span><span class="p">(</span><span class="n">fast</span><span class="p">);</span><span class="w"></span>
<span class="w">                </span><span class="k">break</span><span class="p">;</span><span class="w"></span>
<span class="w">            </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">identifyStartNode</span><span class="p">(</span><span class="n">head</span><span class="p">,</span><span class="w"> </span><span class="n">cycleLength</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">  </span><span class="k">private</span><span class="o">:</span><span class="w"></span>
<span class="w">    </span><span class="k">static</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">calculateCycleLength</span><span class="p">(</span><span class="n">Node</span><span class="w"> </span><span class="o">*</span><span class="n">node</span><span class="p">){</span><span class="w"></span>
<span class="w">        </span><span class="n">Node</span><span class="w"> </span><span class="o">*</span><span class="n">current</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">node</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">cycleLength</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="k">do</span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="n">cycleLength</span><span class="o">++</span><span class="p">;</span><span class="w"></span>
<span class="w">            </span><span class="n">current</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">current</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="k">while</span><span class="p">(</span><span class="n">current</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">node</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">cycleLength</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="k">static</span><span class="w"> </span><span class="n">Node</span><span class="w"> </span><span class="o">*</span><span class="n">identifyStartNode</span><span class="p">(</span><span class="n">Node</span><span class="w"> </span><span class="o">*</span><span class="n">head</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">cycleLength</span><span class="p">){</span><span class="w"></span>
<span class="w">        </span><span class="n">Node</span><span class="w"> </span><span class="o">*</span><span class="n">ptr1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">head</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="n">Node</span><span class="w"> </span><span class="o">*</span><span class="n">ptr2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">head</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="k">while</span><span class="p">(</span><span class="n">cycleLength</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">0</span><span class="p">){</span><span class="w"></span>
<span class="w">            </span><span class="n">cycleLength</span><span class="o">--</span><span class="p">;</span><span class="w"></span>
<span class="w">            </span><span class="n">ptr2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ptr2</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>

<span class="w">        </span><span class="k">while</span><span class="p">(</span><span class="n">ptr1</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">ptr2</span><span class="p">){</span><span class="w"></span>
<span class="w">            </span><span class="n">ptr1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ptr1</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span><span class="w"></span>
<span class="w">            </span><span class="n">ptr2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ptr2</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">ptr1</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">(){</span><span class="w"></span>
<span class="w">    </span><span class="n">Node</span><span class="w"> </span><span class="o">*</span><span class="n">head</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">Node</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">head</span><span class="o">-&gt;</span><span class="n">next</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">Node</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">head</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">next</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">Node</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">head</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">next</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">Node</span><span class="p">(</span><span class="mi">4</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">head</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">next</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">Node</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">head</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">next</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">Node</span><span class="p">(</span><span class="mi">6</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">head</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">next</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">Node</span><span class="p">(</span><span class="mi">7</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">head</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">next</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">Node</span><span class="p">(</span><span class="mi">8</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span>
<span class="w">    </span><span class="c1">//Need to work on this scenario</span>
<span class="w">    </span><span class="c1">//head-&gt;next-&gt;next = head;</span>
<span class="w">    </span><span class="c1">//cout &lt;&lt; &quot;LL1 node: &quot; &lt;&lt; LLCycleHead::identifyCycleHead(head)-&gt;value &lt;&lt; endl;</span>

<span class="w">    </span><span class="n">head</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">next</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">head</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;LL2 node: &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">LLCycleHead</span><span class="o">::</span><span class="n">identifyCycleHead</span><span class="p">(</span><span class="n">head</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">value</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">endl</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="n">head</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">next</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">head</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;LL3 node: &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">LLCycleHead</span><span class="o">::</span><span class="n">identifyCycleHead</span><span class="p">(</span><span class="n">head</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">value</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">endl</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="o">!</span> ./cpp/fastSlowPointers/linkedListCycleHead
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>LL2 node: 1
LL3 node: 3
</pre></div>
</div>
</div>
</div>
</section>
</section>
<section id="merge-intervals">
<h3>Merge Intervals<a class="headerlink" href="#merge-intervals" title="Permalink to this headline">#</a></h3>
<section id="id1">
<h4>Merge Intervals<a class="headerlink" href="#id1" title="Permalink to this headline">#</a></h4>
<p>`# %load ./cpp/mergeIntervals/mergeIntervals.cpp</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>
<span class="cp">#include</span><span class="cpf">&lt;vector&gt;</span><span class="cp"></span>

<span class="k">using</span><span class="w"> </span><span class="k">namespace</span><span class="w"> </span><span class="nn">std</span><span class="p">;</span><span class="w"></span>

<span class="k">class</span><span class="w"> </span><span class="nc">Interval</span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">public</span><span class="o">:</span><span class="w"></span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">start</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">end</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="n">Interval</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">start</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">end</span><span class="p">){</span><span class="w"></span>
<span class="w">            </span><span class="k">this</span><span class="o">-&gt;</span><span class="n">start</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">start</span><span class="p">;</span><span class="w"></span>
<span class="w">            </span><span class="k">this</span><span class="o">-&gt;</span><span class="n">end</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">end</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span>
<span class="p">};</span><span class="w"></span>

<span class="k">class</span><span class="w"> </span><span class="nc">MergeIntervals</span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">public</span><span class="o">:</span><span class="w"></span>
<span class="w">        </span><span class="k">static</span><span class="w"> </span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Interval</span><span class="o">&gt;</span><span class="w"> </span><span class="n">mergeOverlappingIntervals</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Interval</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="n">intervals</span><span class="p">){</span><span class="w"></span>
<span class="w">            </span><span class="k">if</span><span class="p">(</span><span class="n">intervals</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">2</span><span class="p">){</span><span class="w"></span>
<span class="w">                </span><span class="k">return</span><span class="w"> </span><span class="n">intervals</span><span class="p">;</span><span class="w"></span>
<span class="w">            </span><span class="p">}</span><span class="w"></span>

<span class="w">            </span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Interval</span><span class="o">&gt;</span><span class="w"> </span><span class="n">res</span><span class="p">;</span><span class="w"></span>
<span class="w">            </span><span class="n">sort</span><span class="p">(</span><span class="n">intervals</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span><span class="w"> </span><span class="n">intervals</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span><span class="w"> </span><span class="p">[](</span><span class="k">const</span><span class="w"> </span><span class="n">Interval</span><span class="w"> </span><span class="o">&amp;</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">Interval</span><span class="w"> </span><span class="o">&amp;</span><span class="n">y</span><span class="p">){</span><span class="k">return</span><span class="w"> </span><span class="n">x</span><span class="p">.</span><span class="n">start</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">y</span><span class="p">.</span><span class="n">start</span><span class="p">;});</span><span class="w"></span>

<span class="w">            </span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Interval</span><span class="o">&gt;::</span><span class="n">const_iterator</span><span class="w"> </span><span class="n">itr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">intervals</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span><span class="w"></span>
<span class="w">            </span><span class="n">Interval</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">*</span><span class="n">itr</span><span class="o">++</span><span class="p">;</span><span class="w"></span>
<span class="w">            </span><span class="kt">int</span><span class="w"> </span><span class="n">start</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">i</span><span class="p">.</span><span class="n">start</span><span class="p">;</span><span class="w"></span>
<span class="w">            </span><span class="kt">int</span><span class="w"> </span><span class="n">end</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">i</span><span class="p">.</span><span class="n">end</span><span class="p">;</span><span class="w"></span>
<span class="w">            </span><span class="k">while</span><span class="p">(</span><span class="n">itr</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">intervals</span><span class="p">.</span><span class="n">end</span><span class="p">()){</span><span class="w"></span>
<span class="w">                </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">*</span><span class="n">itr</span><span class="o">++</span><span class="p">;</span><span class="w"> </span>
<span class="w">                </span><span class="k">if</span><span class="p">(</span><span class="n">i</span><span class="p">.</span><span class="n">start</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">end</span><span class="p">){</span><span class="w"></span>
<span class="w">                    </span><span class="n">end</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">max</span><span class="p">(</span><span class="n">i</span><span class="p">.</span><span class="n">end</span><span class="p">,</span><span class="w"> </span><span class="n">end</span><span class="p">);</span><span class="w"></span>
<span class="w">                </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                    </span><span class="n">res</span><span class="p">.</span><span class="n">push_back</span><span class="p">({</span><span class="n">start</span><span class="p">,</span><span class="w"> </span><span class="n">end</span><span class="p">});</span><span class="w"></span>
<span class="w">                    </span><span class="n">start</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">i</span><span class="p">.</span><span class="n">start</span><span class="p">;</span><span class="w"></span>
<span class="w">                    </span><span class="n">end</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">i</span><span class="p">.</span><span class="n">end</span><span class="p">;</span><span class="w"></span>
<span class="w">                </span><span class="p">}</span><span class="w"></span>
<span class="w">            </span><span class="p">}</span><span class="w"></span>
<span class="w">            </span><span class="n">res</span><span class="p">.</span><span class="n">push_back</span><span class="p">({</span><span class="n">start</span><span class="p">,</span><span class="w"> </span><span class="n">end</span><span class="p">});</span><span class="w"></span>

<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="n">res</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w">   </span>
<span class="p">};</span><span class="w"></span>

<span class="kt">void</span><span class="w"> </span><span class="nf">printOutput</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Interval</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="n">input</span><span class="p">){</span><span class="w"></span>
<span class="w">    </span><span class="k">for</span><span class="p">(</span><span class="k">auto</span><span class="w"> </span><span class="n">p</span><span class="o">:</span><span class="w"> </span><span class="n">input</span><span class="p">){</span><span class="w"></span>
<span class="w">        </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;(&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">p</span><span class="p">.</span><span class="n">start</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot; &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">p</span><span class="p">.</span><span class="n">end</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;)&quot;</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">endl</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kt">void</span><span class="w"> </span><span class="nf">calculate</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Interval</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="n">input</span><span class="p">){</span><span class="w"></span>
<span class="w">    </span><span class="n">printOutput</span><span class="p">(</span><span class="n">input</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Interval</span><span class="o">&gt;</span><span class="w"> </span><span class="n">interval</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">MergeIntervals</span><span class="o">::</span><span class="n">mergeOverlappingIntervals</span><span class="p">(</span><span class="n">input</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">printOutput</span><span class="p">(</span><span class="n">interval</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot; ---- &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">endl</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">(){</span><span class="w"></span>
<span class="w">    </span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Interval</span><span class="o">&gt;</span><span class="w"> </span><span class="n">input</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{{</span><span class="mi">7</span><span class="p">,</span><span class="mi">9</span><span class="p">},</span><span class="w"> </span><span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">},</span><span class="w"> </span><span class="p">{</span><span class="mi">2</span><span class="p">,</span><span class="mi">5</span><span class="p">}};</span><span class="w"> </span><span class="c1">//, {7,9}};</span>
<span class="w">    </span><span class="n">calculate</span><span class="p">(</span><span class="n">input</span><span class="p">);</span><span class="w"> </span>
<span class="w"> </span>
<span class="w">    </span><span class="n">input</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{{</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">},</span><span class="w"> </span><span class="p">{</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">},</span><span class="w"> </span><span class="p">{</span><span class="mi">5</span><span class="p">,</span><span class="mi">9</span><span class="p">}};</span><span class="w"></span>
<span class="w">    </span><span class="n">calculate</span><span class="p">(</span><span class="n">input</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="n">input</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{{</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">},</span><span class="w"> </span><span class="p">{</span><span class="mi">2</span><span class="p">,</span><span class="mi">6</span><span class="p">},</span><span class="w"> </span><span class="p">{</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">}};</span><span class="w"></span>
<span class="w">    </span><span class="n">calculate</span><span class="p">(</span><span class="n">input</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w">    </span>
</pre></div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="o">!</span> ./cpp/mergeIntervals/mergeIntervals
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>(7 9)(1 3)(2 5)
(1 5)(7 9)
 ---- 
(6 7)(2 4)(5 9)
(2 4)(5 9)
 ---- 
(1 4)(2 6)(3 5)
(1 6)
 ---- 
</pre></div>
</div>
</div>
</div>
</section>
</section>
<section id="todo">
<h3>TODO<a class="headerlink" href="#todo" title="Permalink to this headline">#</a></h3>
<ul class="simple">
<li><p>Cyclic Sort</p></li>
<li><p>In-place Reversal of LinkedList</p></li>
<li><p>Tree Breadth First Search</p></li>
<li><p>Tree Depth First Search</p></li>
<li><p>Two Heaps</p></li>
<li><p>Subsets</p></li>
<li><p>Modified Binary Search</p></li>
<li><p>Bitwise XOR</p></li>
<li><p>Top K Elements</p></li>
<li><p>K-way merge</p></li>
<li><p>Dynamic Programming</p></li>
<li><p>Topological Sort</p></li>
</ul>
</section>
<section id="codeforces">
<h3>CodeForces<a class="headerlink" href="#codeforces" title="Permalink to this headline">#</a></h3>
<section id="id2">
<h4>Most Similar Words<a class="headerlink" href="#id2" title="Permalink to this headline">#</a></h4>
</section>
</section>
</section>
<section id="java">
<h2>Java<a class="headerlink" href="#java" title="Permalink to this headline">#</a></h2>
<section id="codechef">
<h3>CodeChef<a class="headerlink" href="#codechef" title="Permalink to this headline">#</a></h3>
<section id="goodpairs">
<h4>GoodPairs<a class="headerlink" href="#goodpairs" title="Permalink to this headline">#</a></h4>
<p>`# %load javaCodes/GoodPairs.java</p>
<div class="highlight-java notranslate"><div class="highlight"><pre><span></span><span class="kn">package</span> <span class="nn">javaCodes</span><span class="p">;</span>

<span class="kn">import</span> <span class="nn">java.util.*</span><span class="p">;</span>
<span class="kn">import</span> <span class="nn">java.lang.*</span><span class="p">;</span>
<span class="kn">import</span> <span class="nn">java.io.*</span><span class="p">;</span>

<span class="kd">class</span> <span class="nc">GoodPairs</span>
<span class="p">{</span>
<span class="cm">/*</span>
<span class="cm">    You are given arrays A and B of length N each. Determine the number of good pairs.</span>

<span class="cm">    A pair (i,j) (1≤i,j≤N) is said to be good if all of the following conditions are satisfied:</span>
<span class="cm">        i&lt;j;</span>
<span class="cm">        A_i=B_j;</span>
<span class="cm">        A_j=B_i;</span>

<span class="cm">    Input Format</span>
<span class="cm">        First line will contain T, the number of test cases. Then the test cases follow.</span>
<span class="cm">    Description of each test case:</span>
<span class="cm">        First line contains an integer N - denoting the length of the arrays.</span>
<span class="cm">        Second line contains N space-separated integers A1,A2,…AN - denoting the array A.</span>
<span class="cm">        Third line contains N space-separated integers B1,B2,…BN - denoting the array B.</span>
<span class="cm">    Output Format</span>
<span class="cm">        For each test case, output the number of good pairs.</span>
<span class="cm">    Constraints</span>
<span class="cm">        1 ≤ T ≤ 1000</span>
<span class="cm">        2 ≤ N ≤ 10^5</span>
<span class="cm">        1 ≤ A_i, B_i ≤ 10^9</span>
<span class="cm">        Sum of N over all test cases does not exceed 2⋅10^5.</span>

<span class="cm">    Sample Input 1</span>
<span class="cm">        4</span>
<span class="cm">        3</span>
<span class="cm">        1 2 3</span>
<span class="cm">        3 2 1</span>
<span class="cm">        4</span>
<span class="cm">        1 2 3 4</span>
<span class="cm">        5 6 6 7</span>
<span class="cm">        3</span>
<span class="cm">        10 10 10</span>
<span class="cm">        10 10 10</span>
<span class="cm">        4</span>
<span class="cm">        4 8 1 1</span>
<span class="cm">        8 4 1 1</span>
<span class="cm">    Sample Output 1</span>
<span class="cm">        1</span>
<span class="cm">        0</span>
<span class="cm">        3</span>
<span class="cm">        2</span>

<span class="cm">    Explanation</span>
<span class="cm">    Test Case 1: The only good pair (i,j) is (1,3). Here,</span>
<span class="cm">        1&lt;3</span>
<span class="cm">        A1=1 and B3=1. Thus, A1=B3.</span>
<span class="cm">        A3=3 and B1=3. Thus, A3=B1.</span>
<span class="cm">    Test Case 2: There are no good pairs.</span>
<span class="cm">    Test Case 3: There are 3 good pairs (i,j). These are (1,2),(1,3), and (2,3).</span>
<span class="cm">    Test Case 4: There are 2 good pairs (i,j). These are (1,2) and (3,4).</span>
<span class="cm">    </span>
<span class="cm">*/</span>
	<span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span> <span class="p">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="p">)</span> <span class="kd">throws</span> <span class="n">java</span><span class="p">.</span><span class="na">lang</span><span class="p">.</span><span class="na">Exception</span>
	<span class="p">{</span>
		<span class="n">Scanner</span> <span class="n">sc</span><span class="o">=</span> <span class="k">new</span> <span class="n">Scanner</span><span class="p">(</span><span class="n">System</span><span class="p">.</span><span class="na">in</span><span class="p">);</span>
		<span class="k">if</span><span class="p">(</span><span class="n">sc</span><span class="p">.</span><span class="na">hasNext</span><span class="p">())</span>
		<span class="p">{</span>
		    <span class="kt">int</span> <span class="n">t</span> <span class="o">=</span> <span class="n">sc</span><span class="p">.</span><span class="na">nextInt</span><span class="p">();</span>
		    <span class="k">while</span><span class="p">(</span><span class="n">t</span><span class="o">--&gt;</span><span class="mi">0</span><span class="p">)</span>
		    <span class="p">{</span>
		        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">sc</span><span class="p">.</span><span class="na">nextInt</span><span class="p">();</span>
		        <span class="kt">int</span><span class="o">[]</span> <span class="n">a</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">n</span><span class="o">]</span><span class="p">;</span>
		        <span class="kt">int</span><span class="o">[]</span> <span class="n">b</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">n</span><span class="o">]</span><span class="p">;</span>
		        
		        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">p</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">p</span><span class="o">&lt;</span><span class="n">n</span><span class="p">;</span><span class="n">p</span><span class="o">++</span><span class="p">)</span> <span class="n">a</span><span class="o">[</span><span class="n">p</span><span class="o">]=</span><span class="n">sc</span><span class="p">.</span><span class="na">nextInt</span><span class="p">();</span>
		        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">p</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">p</span><span class="o">&lt;</span><span class="n">n</span><span class="p">;</span><span class="n">p</span><span class="o">++</span><span class="p">)</span> <span class="n">b</span><span class="o">[</span><span class="n">p</span><span class="o">]=</span><span class="n">sc</span><span class="p">.</span><span class="na">nextInt</span><span class="p">();</span>
		        
		        <span class="n">HashMap</span><span class="o">&lt;</span><span class="n">String</span><span class="p">,</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">map</span> <span class="o">=</span> <span class="k">new</span> <span class="n">HashMap</span><span class="o">&lt;&gt;</span><span class="p">();</span>
		        <span class="kt">long</span> <span class="n">ans</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		        
		        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">n</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
		        <span class="p">{</span>
		            <span class="n">String</span> <span class="n">temp</span> <span class="o">=</span> <span class="n">a</span><span class="o">[</span><span class="n">i</span><span class="o">]+</span><span class="s">&quot;-&quot;</span><span class="o">+</span><span class="n">b</span><span class="o">[</span><span class="n">i</span><span class="o">]</span><span class="p">;</span>
		            <span class="kt">int</span> <span class="n">m</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		            <span class="k">if</span><span class="p">(</span><span class="n">map</span><span class="p">.</span><span class="na">containsKey</span><span class="p">(</span><span class="n">temp</span><span class="p">)</span> <span class="p">)</span>
		            <span class="p">{</span>
		                <span class="n">ans</span> <span class="o">=</span> <span class="n">ans</span> <span class="o">+</span> <span class="n">map</span><span class="p">.</span><span class="na">get</span><span class="p">(</span><span class="n">temp</span><span class="p">);</span>
                                <span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="s">&quot;P1:i=&quot;</span> <span class="o">+</span> <span class="n">i</span> <span class="o">+</span> <span class="s">&quot;:ans=&quot;</span> <span class="o">+</span> <span class="n">ans</span> <span class="o">+</span> <span class="s">&quot;:map=&quot;</span> <span class="o">+</span> <span class="n">Collections</span><span class="p">.</span><span class="na">singletonList</span><span class="p">(</span><span class="n">map</span><span class="p">));</span>
		            <span class="p">}</span>
		            <span class="n">temp</span> <span class="o">=</span> <span class="n">b</span><span class="o">[</span><span class="n">i</span><span class="o">]+</span><span class="s">&quot;-&quot;</span><span class="o">+</span><span class="n">a</span><span class="o">[</span><span class="n">i</span><span class="o">]</span><span class="p">;</span>
		            <span class="k">if</span><span class="p">(</span> <span class="n">map</span><span class="p">.</span><span class="na">containsKey</span><span class="p">(</span><span class="n">temp</span><span class="p">)</span> <span class="p">)</span> <span class="p">{</span>
                                <span class="n">map</span><span class="p">.</span><span class="na">put</span><span class="p">(</span> <span class="n">temp</span><span class="p">,</span> <span class="n">map</span><span class="p">.</span><span class="na">get</span><span class="p">(</span><span class="n">temp</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span>  <span class="p">);</span>
                                <span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="s">&quot;P2:i=&quot;</span> <span class="o">+</span> <span class="n">i</span> <span class="o">+</span> <span class="s">&quot;:ans=&quot;</span> <span class="o">+</span> <span class="n">ans</span> <span class="o">+</span> <span class="s">&quot;:map=&quot;</span> <span class="o">+</span> <span class="n">Collections</span><span class="p">.</span><span class="na">singletonList</span><span class="p">(</span><span class="n">map</span><span class="p">));</span>
                            <span class="p">}</span>
		            <span class="k">else</span><span class="p">{</span> 
                                <span class="n">map</span><span class="p">.</span><span class="na">put</span><span class="p">(</span><span class="n">temp</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
                                <span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="s">&quot;P3:i=&quot;</span> <span class="o">+</span> <span class="n">i</span> <span class="o">+</span> <span class="s">&quot;:ans=&quot;</span> <span class="o">+</span> <span class="n">ans</span> <span class="o">+</span> <span class="s">&quot;:map=&quot;</span> <span class="o">+</span> <span class="n">Collections</span><span class="p">.</span><span class="na">singletonList</span><span class="p">(</span><span class="n">map</span><span class="p">));</span>
                            <span class="p">}</span>
		        <span class="p">}</span>
		        
                <span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="n">ans</span><span class="p">);</span>
		    <span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>(base) algos &gt;&gt; java javaCodes/GoodPairs
1
4
1 1 1 1
1 1 1 1
P3:i=0:ans=0:map=[{1-1=1}]
P1:i=1:ans=1:map=[{1-1=1}]
P2:i=1:ans=1:map=[{1-1=2}]
P1:i=2:ans=3:map=[{1-1=2}]
P2:i=2:ans=3:map=[{1-1=3}]
P1:i=3:ans=6:map=[{1-1=3}]
P2:i=3:ans=6:map=[{1-1=4}]
6


(base) algos &gt;&gt; java javaCodes/GoodPairs
1
3
1 2 3
3 2 1
P3:i=0:ans=0:map=[{3-1=1}]
P3:i=1:ans=0:map=[{3-1=1, 2-2=1}]
P1:i=2:ans=1:map=[{3-1=1, 2-2=1}]
P3:i=2:ans=1:map=[{3-1=1, 2-2=1, 1-3=1}]
1


(base) algos &gt;&gt; java javaCodes/GoodPairs
1
4
1 2 3 4
5 6 6 7
P3:i=0:ans=0:map=[{5-1=1}]
P3:i=1:ans=0:map=[{5-1=1, 6-2=1}]
P3:i=2:ans=0:map=[{5-1=1, 6-2=1, 6-3=1}]
P3:i=3:ans=0:map=[{5-1=1, 6-2=1, 6-3=1, 7-4=1}]
0


(base) algos &gt;&gt; java javaCodes/GoodPairs
1
6
4 8 1 1 1 1
8 4 1 1 1 1
P3:i=0:ans=0:map=[{8-4=1}]
P1:i=1:ans=1:map=[{8-4=1}]
P3:i=1:ans=1:map=[{8-4=1, 4-8=1}]
P3:i=2:ans=1:map=[{1-1=1, 8-4=1, 4-8=1}]
P1:i=3:ans=2:map=[{1-1=1, 8-4=1, 4-8=1}]
P2:i=3:ans=2:map=[{1-1=2, 8-4=1, 4-8=1}]
P1:i=4:ans=4:map=[{1-1=2, 8-4=1, 4-8=1}]
P2:i=4:ans=4:map=[{1-1=3, 8-4=1, 4-8=1}]
P1:i=5:ans=7:map=[{1-1=3, 8-4=1, 4-8=1}]
P2:i=5:ans=7:map=[{1-1=4, 8-4=1, 4-8=1}]
7


(base) algos &gt;&gt;
</pre></div>
</div>
</section>
</section>
</section>
</section>

    <script type="text/x-thebe-config">
    {
        requestKernel: true,
        binderOptions: {
            repo: "binder-examples/jupyter-stacks-datascience",
            ref: "master",
        },
        codeMirrorConfig: {
            theme: "abcdef",
            mode: "python"
        },
        kernelOptions: {
            kernelName: "python3",
            path: "./algos"
        },
        predefinedOutput: true
    }
    </script>
    <script>kernelName = 'python3'</script>

              </div>
              
            </main>
            <footer class="footer-article noprint">
                
    <!-- Previous / next buttons -->
<div class='prev-next-area'>
    <a class='left-prev' id="prev-link" href="../codes/python_faqs.html" title="previous page">
        <i class="fas fa-angle-left"></i>
        <div class="prev-next-info">
            <p class="prev-next-subtitle">previous</p>
            <p class="prev-next-title">Python FAQs</p>
        </div>
    </a>
    <a class='right-next' id="next-link" href="../codes/python_data_analytics.html" title="next page">
    <div class="prev-next-info">
        <p class="prev-next-subtitle">next</p>
        <p class="prev-next-title">Python Data Analytics - FAQs</p>
    </div>
    <i class="fas fa-angle-right"></i>
    </a>
</div>
            </footer>
        </div>
    </div>
    <div class="footer-content row">
        <footer class="col footer"><p>
  
    By Chandra<br/>
  
      &copy; Copyright 2022.<br/>
</p>
        </footer>
    </div>
    
</div>


      </div>
    </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="../_static/scripts/pydata-sphinx-theme.js?digest=1999514e3f237ded88cf"></script>


  </body>
</html>